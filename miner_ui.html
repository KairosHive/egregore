<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="assets/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Egregore</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // Inline OrbitControls for reliability
    THREE.OrbitControls = function(object, domElement) {
        this.object = object;
        this.domElement = domElement;
        this.enabled = true;
        this.target = new THREE.Vector3();
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        this.enableZoom = true;
        this.zoomSpeed = 1.0;
        this.enableRotate = true;
        this.rotateSpeed = 1.0;
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0;
        
        var scope = this;
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();
        var scale = 1;
        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();
        var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1 };
        var state = STATE.NONE;
        
        this.update = function() {
            var offset = new THREE.Vector3();
            var position = scope.object.position;
            offset.copy(position).sub(scope.target);
            spherical.setFromVector3(offset);
            if (scope.autoRotate && state === STATE.NONE) {
                spherical.theta += 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
            }
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
            spherical.radius *= scale;
            spherical.radius = Math.max(0.5, Math.min(20, spherical.radius));
            offset.setFromSpherical(spherical);
            position.copy(scope.target).add(offset);
            scope.object.lookAt(scope.target);
            if (scope.enableDamping) {
                sphericalDelta.theta *= (1 - scope.dampingFactor);
                sphericalDelta.phi *= (1 - scope.dampingFactor);
            } else {
                sphericalDelta.set(0, 0, 0);
            }
            scale = 1;
            return false;
        };
        
        function onMouseDown(event) {
            if (!scope.enabled) return;
            event.preventDefault();
            if (event.button === 0) {
                state = STATE.ROTATE;
                rotateStart.set(event.clientX, event.clientY);
            }
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
        }
        
        function onMouseMove(event) {
            if (!scope.enabled) return;
            event.preventDefault();
            if (state === STATE.ROTATE) {
                rotateEnd.set(event.clientX, event.clientY);
                rotateDelta.subVectors(rotateEnd, rotateStart);
                var element = scope.domElement;
                sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed;
                sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed;
                rotateStart.copy(rotateEnd);
            }
        }
        
        function onMouseUp() {
            if (!scope.enabled) return;
            document.removeEventListener('mousemove', onMouseMove, false);
            document.removeEventListener('mouseup', onMouseUp, false);
            state = STATE.NONE;
        }
        
        function onWheel(event) {
            if (!scope.enabled || !scope.enableZoom) return;
            event.preventDefault();
            if (event.deltaY < 0) scale /= Math.pow(0.95, scope.zoomSpeed);
            else if (event.deltaY > 0) scale *= Math.pow(0.95, scope.zoomSpeed);
        }
        
        this.domElement.addEventListener('mousedown', onMouseDown, false);
        this.domElement.addEventListener('wheel', onWheel, { passive: false });
        this.update();
    };
    </script>
    <style>
        :root {
            --bg-primary: #0a0a0c;
            --bg-secondary: #101014;
            --bg-tertiary: #18181b;
            --bg-elevated: #1f1f23;
            
            /* Panel accent colors */
            --panel-orange: rgba(230, 126, 34, 0.08);
            --panel-orange-border: rgba(230, 126, 34, 0.25);
            --panel-orange-text: #e67e22;
            
            --panel-turquoise: rgba(26, 188, 156, 0.08);
            --panel-turquoise-border: rgba(26, 188, 156, 0.25);
            --panel-turquoise-text: #1abc9c;
            
            --panel-purple: rgba(194, 166, 254, 0.08);
            --panel-purple-border: rgba(194, 166, 254, 0.25);
            --panel-purple-text: #c2a6fe;
            
            --accent-primary: #a1c4fd;
            --accent-secondary: #c2a6fe;
            --accent-glow: rgba(161, 196, 253, 0.15);
            --success: #22c55e;
            --warning: #eab308;
            --error: #ef4444;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --border: rgba(255, 255, 255, 0.06);
            --border-hover: rgba(255, 255, 255, 0.12);
            --radius: 12px;
            --radius-sm: 6px;
            --transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 1rem 1.25rem;
        }
        
        /* Delyrism-style Header */
        @keyframes glow-pulse {
            0%, 100% { 
                filter: drop-shadow(0 0 4px rgba(161, 196, 253, 0.15));
            }
            50% { 
                filter: drop-shadow(0 0 8px rgba(161, 196, 253, 0.25))
                        drop-shadow(0 0 15px rgba(194, 166, 254, 0.15));
            }
        }
        
        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes drip-fall {
            0% { transform: translateY(0); opacity: 0.7; }
            100% { transform: translateY(50px); opacity: 0; }
        }
        
        @keyframes drip-spawn {
            0%, 100% { opacity: 0; }
            10%, 40% { opacity: 0.6; }
        }
        
        header {
            text-align: center;
            padding: 0.5rem 0 1.5rem;
            position: relative;
        }
        
        .title-container {
            position: relative;
            display: inline-block;
        }
        
        .title {
            font-size: 3rem;
            font-weight: 200;
            letter-spacing: 0.12em;
            background: linear-gradient(120deg, #ffffff 0%, #a1c4fd 50%, #c2a6fe 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            line-height: 1.1;
            animation: glow-pulse 4s ease-in-out infinite, gradient-shift 8s ease infinite;
            filter: drop-shadow(0 0 4px rgba(161, 196, 253, 0.15));
        }
        
        .drip-container {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            height: 50px;
            pointer-events: none;
            overflow: hidden;
        }
        
        .drip {
            position: absolute;
            font-size: 0.9rem;
            font-weight: 200;
            background: linear-gradient(180deg, #a1c4fd 0%, transparent 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: drip-fall 3s ease-in infinite, drip-spawn 3s ease-in-out infinite;
            opacity: 0;
        }
        
        .drip:nth-child(1) { left: 5%; animation-delay: 0s; }
        .drip:nth-child(2) { left: 15%; animation-delay: 0.7s; }
        .drip:nth-child(3) { left: 28%; animation-delay: 1.4s; }
        .drip:nth-child(4) { left: 40%; animation-delay: 2.1s; }
        .drip:nth-child(5) { left: 52%; animation-delay: 0.3s; }
        .drip:nth-child(6) { left: 65%; animation-delay: 1.8s; }
        .drip:nth-child(7) { left: 78%; animation-delay: 1.1s; }
        .drip:nth-child(8) { left: 90%; animation-delay: 2.5s; }
        
        .subtitle {
            font-size: 0.7rem;
            color: #8899a6;
            letter-spacing: 0.35em;
            text-transform: uppercase;
            margin-top: 0.5rem;
        }
        
        .connection-badge {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            padding: 0.35rem 0.65rem;
            background: var(--bg-tertiary);
            border-radius: 20px;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
        }
        
        .connection-badge:hover {
            border-color: var(--border-hover);
            background: var(--bg-secondary);
        }
        
        .connection-badge:hover::after {
            content: 'Click to reconnect';
            position: absolute;
            bottom: -24px;
            right: 0;
            font-size: 0.6rem;
            color: var(--text-muted);
            white-space: nowrap;
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }
        
        .connection-badge.connected:hover::after {
            content: 'Connected - Click to refresh';
        }
        
        .header-controls {
            position: absolute;
            right: 120px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .header-control-group {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .header-control-group label {
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        .header-control-group select,
        .header-control-group input[type="number"] {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.65rem;
            padding: 0.25rem 0.4rem;
            outline: none;
            transition: border-color 0.2s ease;
        }
        
        .header-control-group select:hover,
        .header-control-group input[type="number"]:hover {
            border-color: var(--border-hover);
        }
        
        .header-control-group select:focus,
        .header-control-group input[type="number"]:focus {
            border-color: var(--accent-primary);
        }
        
        .header-control-group select {
            min-width: 70px;
        }
        
        .header-control-group input[type="number"] {
            width: 50px;
            text-align: center;
        }
        
        /* Hide number input spinners */
        .header-control-group input[type="number"]::-webkit-outer-spin-button,
        .header-control-group input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .header-control-group input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }
        
        .status-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: var(--error);
            transition: background var(--transition);
        }
        
        .status-dot.connected { 
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }
        
        .status-dot.reconnecting {
            background: var(--warning);
            animation: pulse-reconnect 1s ease-in-out infinite;
        }
        
        @keyframes pulse-reconnect {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.3); }
        }
        
        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 340px 280px 1fr;
            gap: 1rem;
            height: calc(100vh - 130px);
        }
        
        /* Panel Base */
        .panel {
            border-radius: var(--radius);
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all var(--transition);
            backdrop-filter: blur(8px);
        }
        
        /* Panel: Data Sources (Burnt Orange) */
        .panel.panel-sources {
            background: linear-gradient(180deg, var(--panel-orange) 0%, var(--bg-secondary) 100%);
            border-color: var(--panel-orange-border);
        }
        
        .panel.panel-sources .panel-header {
            color: var(--panel-orange-text);
            border-bottom-color: var(--panel-orange-border);
        }
        
        .panel.panel-sources .tab.active {
            border-bottom-color: var(--panel-orange-text);
            color: var(--panel-orange-text);
        }
        
        /* Panel: Mining Config (Turquoise) */
        .panel.panel-config {
            background: linear-gradient(180deg, var(--panel-turquoise) 0%, var(--bg-secondary) 100%);
            border-color: var(--panel-turquoise-border);
        }
        
        .panel.panel-config .panel-header {
            color: var(--panel-turquoise-text);
            border-bottom-color: var(--panel-turquoise-border);
        }
        
        .panel.panel-config .btn-primary {
            background: linear-gradient(135deg, var(--panel-turquoise-text), #16a085);
        }
        
        /* Panel: Results (Purple Pastel) */
        .panel.panel-results {
            background: linear-gradient(180deg, var(--panel-purple) 0%, var(--bg-secondary) 100%);
            border-color: var(--panel-purple-border);
            position: relative;
            overflow: hidden;
        }
        
        .spectral-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.4;
            z-index: 0;
        }
        
        .panel.panel-results .panel-header,
        .panel.panel-results .results-tabs,
        .panel.panel-results .panel-content,
        .panel.panel-results .export-group {
            position: relative;
            z-index: 1;
        }
        
        .panel.panel-results .panel-header {
            color: var(--panel-purple-text);
            border-bottom-color: var(--panel-purple-border);
        }
        
        .panel.panel-results .results-tab.active {
            border-bottom-color: var(--panel-purple-text);
            color: var(--panel-purple-text);
        }
        
        .panel-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            font-weight: 400;
            font-size: 0.8rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        
        .panel-content {
            padding: 1rem;
            overflow-y: auto;
            flex: 1;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            padding: 0 0.5rem;
        }
        
        .tab {
            padding: 0.6rem 0.8rem;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.75rem;
            font-weight: 400;
            letter-spacing: 0.03em;
            border-bottom: 2px solid transparent;
            transition: all var(--transition);
            margin-bottom: -1px;
        }
        
        .tab:hover { color: var(--text-secondary); }
        
        .tab.active {
            color: var(--text-primary);
        }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; animation: fadeIn 0.25s ease; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Stats Cards */
        .corpus-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .stat-card {
            background: rgba(0, 0, 0, 0.2);
            padding: 0.6rem 0.5rem;
            border-radius: var(--radius-sm);
            text-align: center;
            border: 1px solid var(--panel-orange-border);
            transition: all var(--transition);
        }
        
        .stat-card:hover {
            border-color: var(--panel-orange-text);
            transform: translateY(-1px);
        }
        
        .stat-value {
            font-size: 1.25rem;
            font-weight: 300;
            background: linear-gradient(135deg, var(--panel-orange-text), #f39c12);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }
        
        .stat-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-top: 0.15rem;
        }
        
        /* Form Elements */
        textarea, input[type="text"], input[type="number"], select {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 0.6rem 0.75rem;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.8rem;
            transition: all var(--transition);
        }
        
        textarea { resize: vertical; min-height: 100px; }
        
        textarea:focus, input:focus, select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }
        
        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23a1a1aa'%3E%3Cpath d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            padding-right: 2rem;
        }
        
        .input-group { margin-bottom: 0.65rem; }
        
        .input-label {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 0.35rem;
            font-weight: 500;
            letter-spacing: 0.02em;
        }
        
        .info-btn {
            position: relative;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.4);
            color: var(--accent-primary);
            font-size: 0.55rem;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .info-btn:hover {
            background: rgba(139, 92, 246, 0.4);
            border-color: var(--accent-primary);
        }
        
        .info-tooltip {
            position: fixed;
            background: rgba(15, 10, 30, 0.98);
            border: 1px solid rgba(139, 92, 246, 0.5);
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            width: 220px;
            font-size: 0.6rem;
            font-weight: 400;
            color: var(--text-secondary);
            line-height: 1.5;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s ease, visibility 0.15s ease;
            z-index: 999999;
            pointer-events: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            text-align: left;
        }
        
        .info-tooltip.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .input-row {
            display: flex;
            gap: 0.5rem;
        }
        
        .input-row input { flex: 1; }
        
        /* Buttons */
        .btn {
            padding: 0.55rem 0.9rem;
            border: none;
            border-radius: var(--radius-sm);
            font-weight: 400;
            cursor: pointer;
            transition: all var(--transition);
            font-size: 0.7rem;
            letter-spacing: 0.02em;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            font-family: inherit;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
        }
        
        .btn-primary:hover { 
            filter: brightness(1.1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px var(--accent-glow);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-primary);
            border-color: var(--border-hover);
        }
        
        .btn-danger { 
            background: rgba(239, 68, 68, 0.15); 
            color: var(--error);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .btn-danger:hover { 
            background: rgba(239, 68, 68, 0.25);
        }
        
        .btn-success { background: var(--success); color: white; }
        
        .btn-group { display: flex; gap: 0.5rem; margin-top: 0.65rem; }
        
        .btn:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
        
        .btn-sm { padding: 0.35rem 0.6rem; font-size: 0.65rem; }
        
        .btn-icon {
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: var(--radius-sm);
        }
        
        /* Document Board */
        .doc-board {
            margin-top: 0.75rem;
            max-height: 180px;
            overflow-y: auto;
        }
        
        .doc-section { margin-bottom: 0.65rem; }
        
        .doc-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0.6rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            margin-bottom: 0.4rem;
            color: var(--text-secondary);
        }
        
        .doc-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .doc-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.45rem 0.6rem;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
            border: 1px solid transparent;
            transition: all var(--transition);
        }
        
        .doc-item:hover {
            border-color: var(--border);
        }
        
        .doc-item-info {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .doc-icon {
            font-size: 0.55rem;
            font-weight: 600;
            padding: 0.15rem 0.35rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            color: var(--text-muted);
            letter-spacing: 0.02em;
        }
        
        .doc-item-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 160px;
            color: var(--text-secondary);
        }
        
        .doc-item-meta {
            color: var(--text-muted);
            font-size: 0.6rem;
        }
        
        .doc-item-remove {
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.2rem;
            opacity: 0;
            transition: all var(--transition);
        }
        
        .doc-item:hover .doc-item-remove { opacity: 1; }
        .doc-item-remove:hover { color: var(--error); }
        
        /* Chunk params */
        .chunk-params {
            margin-top: 0.5rem;
            padding: 0.6rem;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            animation: fadeIn 0.2s ease;
        }
        
        .chunk-params .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        
        .chunk-params .input-group { margin-bottom: 0; }
        
        .chunk-preview {
            margin-top: 0.5rem;
            padding: 0.45rem 0.65rem;
            background: var(--accent-glow);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            color: var(--accent-secondary);
        }
        
        /* File buttons */
        .file-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .file-buttons .btn { flex: 1; }
        
        /* Config section */
        .config-compact {
            padding-bottom: 0.65rem;
            border-bottom: 1px solid var(--border);
            margin-bottom: 0.65rem;
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: var(--accent-primary);
        }
        
        /* Radio Group for Semantic Spread */
        .radio-group {
            display: flex;
            gap: 0.3rem;
            width: 100%;
            box-sizing: border-box;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            padding: 0.35rem 0.4rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            cursor: pointer;
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: all var(--transition);
            flex: 1;
            min-width: 0;
            box-sizing: border-box;
        }
        
        .radio-option:hover {
            border-color: var(--panel-turquoise-border);
        }
        
        .radio-option:has(input:checked) {
            background: rgba(26, 188, 156, 0.15);
            border-color: var(--panel-turquoise-text);
            color: var(--panel-turquoise-text);
        }
        
        .radio-option input[type="radio"] {
            width: 12px;
            height: 12px;
            accent-color: var(--panel-turquoise-text);
            margin: 0;
        }
        
        .section-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            letter-spacing: 0.08em;
            font-weight: 500;
        }
        
        /* Progress Panel */
        .progress-container {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .pipeline-stages {
            display: flex;
            gap: 3px;
            margin-bottom: 0.75rem;
        }
        
        .stage {
            flex: 1;
            height: 3px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 2px;
            transition: all var(--transition);
        }
        
        .stage.active {
            background: var(--panel-turquoise-text);
            box-shadow: 0 0 8px rgba(26, 188, 156, 0.4);
            animation: stagePulse 1.5s ease-in-out infinite;
        }
        
        .stage.complete { background: var(--success); }
        .stage.error { background: var(--error); }
        
        @keyframes stagePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .progress-bar-container {
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--panel-turquoise-text), #2ecc71);
            width: 0%;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 2px;
        }
        
        .progress-stage {
            font-size: 0.75rem;
            color: var(--panel-turquoise-text);
            margin-bottom: 0.75rem;
            letter-spacing: 0.02em;
        }
        
        .log-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--radius-sm);
            padding: 0.6rem;
            font-family: 'SF Mono', 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.6rem;
            overflow-y: auto;
            max-height: 140px;
            border: 1px solid var(--panel-turquoise-border);
        }
        
        .log-entry {
            color: var(--text-muted);
            line-height: 1.5;
            word-break: break-all;
            padding: 0.15rem 0;
        }
        
        .log-entry.error { color: var(--error); }
        .log-entry.success { color: var(--success); }
        .log-entry.info { color: var(--panel-turquoise-text); }
        
        /* Results Panel */
        .results-tabs {
            display: flex;
            border-bottom: 1px solid var(--panel-purple-border);
            padding: 0 0.5rem;
            background: rgba(0, 0, 0, 0.15);
        }
        
        .results-tab {
            padding: 0.55rem 0.875rem;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.7rem;
            font-weight: 400;
            letter-spacing: 0.03em;
            border-bottom: 2px solid transparent;
            transition: all var(--transition);
            margin-bottom: -1px;
        }
        
        .results-tab:hover { color: var(--text-secondary); }
        
        .results-tab.active {
            color: var(--panel-purple-text);
        }
        
        .results-content { 
            display: none; 
            height: 100%;
            animation: fadeIn 0.25s ease;
        }
        .results-content.active { display: flex; flex-direction: column; }
        
        /* Metrics Tab - Creative Constellation Visualization */
        .metrics-container {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 0.75rem;
            padding: 0.75rem;
            height: 100%;
            overflow: hidden;
        }
        
        /* Quality Score Hero Card */
        .quality-hero {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, rgba(194, 166, 254, 0.15) 0%, rgba(99, 102, 241, 0.1) 100%);
            border-radius: 10px;
            border: 1px solid rgba(194, 166, 254, 0.3);
        }
        
        .quality-ring {
            position: relative;
            width: 70px;
            height: 70px;
        }
        
        .quality-ring svg {
            transform: rotate(-90deg);
        }
        
        .quality-ring-bg {
            stroke: rgba(255, 255, 255, 0.1);
        }
        
        .quality-ring-fill {
            stroke: url(#qualityGradient);
            stroke-linecap: round;
            transition: stroke-dashoffset 1s ease-out;
        }
        
        .quality-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.3rem;
            font-weight: 300;
            color: var(--panel-purple-text);
        }
        
        .quality-details {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .quality-stat {
            text-align: center;
        }
        
        .quality-stat-value {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .quality-stat-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        
        /* Constellation Visualization Container */
        .constellation-container {
            position: relative;
            display: flex;
            gap: 0.5rem;
            min-height: 0;
            overflow: hidden;
        }
        
        .constellation-canvas-wrapper {
            flex: 1;
            position: relative;
            background: radial-gradient(ellipse at center, rgba(20, 20, 35, 0.9) 0%, rgba(10, 10, 15, 1) 100%);
            border-radius: 10px;
            border: 1px solid rgba(194, 166, 254, 0.15);
            overflow: hidden;
        }
        
        #embedding3DContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #embedding3DContainer canvas {
            width: 100%;
            height: 100%;
        }
        
        .embedding3d-legend {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(10, 10, 12, 0.85);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.6rem;
            color: var(--text-muted);
            pointer-events: none;
            z-index: 10;
        }
        
        .embedding3d-hint {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(10, 10, 12, 0.7);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.55rem;
            color: var(--text-muted);
            pointer-events: none;
            z-index: 10;
        }

        /* Similarity Matrix Panel */
        .similarity-panel {
            width: 180px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .similarity-title {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            margin-bottom: 0.4rem;
            text-align: center;
        }
        
        .similarity-canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }
        
        #similarityMatrix {
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1;
        }
        
        /* Per-Archetype Metrics Cards */
        .archetype-metrics-grid {
            display: flex;
            gap: 0.4rem;
            overflow-x: auto;
            padding-bottom: 0.25rem;
        }
        
        .archetype-metrics-grid::-webkit-scrollbar {
            height: 4px;
        }
        
        .archetype-metric-card {
            flex: 0 0 auto;
            min-width: 140px;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 8px;
            padding: 0.5rem 0.6rem;
            border-left: 3px solid;
            transition: all 0.2s ease;
        }
        
        .archetype-metric-card:hover {
            background: rgba(0, 0, 0, 0.35);
            transform: translateY(-1px);
        }
        
        .archetype-metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
        }
        
        .archetype-metric-name {
            font-size: 0.65rem;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 90px;
        }
        
        .archetype-metric-size {
            font-size: 0.55rem;
            color: var(--text-muted);
            background: rgba(255, 255, 255, 0.08);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
        }
        
        .metric-bars {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .metric-bar-row {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .metric-bar-label {
            font-size: 0.5rem;
            color: var(--text-muted);
            width: 12px;
            text-transform: uppercase;
        }
        
        .metric-bar-track {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .metric-bar-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s ease-out;
        }
        
        .metric-bar-fill.dispersion { background: linear-gradient(90deg, #06b6d4, #22d3ee); }  /* Cyan - distinct from archetypes */
        .metric-bar-fill.leakage { background: linear-gradient(90deg, #f43f5e, #fb7185); }     /* Rose - distinct from archetypes */
        .metric-bar-fill.entropy { background: linear-gradient(90deg, #a3e635, #bef264); }     /* Lime - distinct from archetypes */
        
        .metric-bar-value {
            font-size: 0.5rem;
            color: var(--text-secondary);
            width: 24px;
            text-align: right;
        }
        
        /* Tooltip for constellation */
        .constellation-tooltip {
            position: absolute;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid rgba(194, 166, 254, 0.4);
            border-radius: 6px;
            padding: 0.5rem 0.7rem;
            font-size: 0.7rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 100;
            max-width: 200px;
        }
        
        .constellation-tooltip.visible {
            opacity: 1;
        }
        
        .tooltip-name {
            color: var(--panel-purple-text);
            font-weight: 500;
            margin-bottom: 0.3rem;
        }
        
        .tooltip-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.3rem;
            font-size: 0.6rem;
        }
        
        .tooltip-metric {
            text-align: center;
        }
        
        .tooltip-metric-value {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .tooltip-metric-label {
            color: var(--text-muted);
            font-size: 0.5rem;
        }
        
        /* ================================================
           TOPOLOGY PANEL - Gravitational Fields, Gradients, Metrics
           ================================================ */
        
        .topology-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            height: 100%;
            overflow-y: auto;
            overflow-x: visible;
            padding-top: 5px;
        }
        
        /* Gravity Well Visualization */
        .gravity-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid var(--border);
            padding: 0.75rem;
            overflow: visible;
            position: relative;
        }
        
        .topology-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .topology-section-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 6px;
            font-size: 0.8rem;
        }
        
        .topology-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .topology-section-subtitle {
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-left: auto;
        }
        
        .gravity-canvas-container {
            position: relative;
            height: 280px;
            background: radial-gradient(ellipse at center, rgba(15, 10, 30, 0.95) 0%, rgba(5, 5, 10, 1) 100%);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #gravityCanvas {
            width: 100%;
            height: 100%;
        }
        
        .gravity-legend {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(10, 10, 12, 0.85);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.55rem;
            color: var(--text-muted);
        }
        
        /* Gradient Flow Visualization */
        .gradient-flow-container {
            position: relative;
            height: 200px;
            background: radial-gradient(ellipse at center, rgba(10, 15, 25, 0.95) 0%, rgba(5, 5, 10, 1) 100%);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #gradientCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* Topology Metrics Cards */
        .topology-metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            overflow: visible;
            position: relative;
        }
        
        .topology-metric-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 0.75rem;
            text-align: center;
            transition: all 0.2s ease;
            position: relative;
            cursor: help;
            z-index: 1;
        }
        
        .topology-metric-card:hover {
            border-color: rgba(139, 92, 246, 0.4);
            background: rgba(139, 92, 246, 0.1);
            z-index: 100;
        }
        
        .topology-metric-card:hover .metric-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
        
        .metric-tooltip {
            position: absolute;
            left: 50%;
            top: calc(100% + 8px);
            transform: translateX(-50%) translateY(-5px);
            background: rgba(15, 10, 30, 0.98);
            border: 1px solid rgba(139, 92, 246, 0.5);
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            width: 180px;
            font-size: 0.6rem;
            color: var(--text-secondary);
            line-height: 1.4;
            opacity: 0;
            visibility: hidden;
            transition: all 0.15s ease;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            text-align: left;
        }
        
        .metric-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: rgba(139, 92, 246, 0.5);
        }
        
        .metric-tooltip-title {
            color: var(--accent-primary);
            font-weight: 600;
            margin-bottom: 0.3rem;
            font-size: 0.65rem;
        }
        
        .topology-metric-value {
            font-size: 1.4rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .topology-metric-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 0.25rem;
        }
        
        .topology-metric-sublabel {
            font-size: 0.5rem;
            color: var(--text-muted);
            opacity: 0.7;
        }
        
        /* ================================================
           VISUALS TAB - AI Generated Archetype Art
           ================================================ */
        
        .visuals-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            height: 100%;
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        .visuals-config-section,
        .visuals-selection-section,
        .visuals-style-section,
        .visuals-generate-section,
        .visuals-gallery-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid var(--border);
            padding: 0.75rem;
        }
        
        .api-key-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .api-key-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            color: var(--text-primary);
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .api-key-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .api-key-hint {
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }
        
        .api-key-hint a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        .api-key-hint a:hover {
            text-decoration: underline;
        }
        
        .archetype-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-top: 0.5rem;
        }
        
        .archetype-chip {
            padding: 0.35rem 0.65rem;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 20px;
            font-size: 0.65rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        .archetype-chip:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 0.5);
        }
        
        .archetype-chip.selected {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-color: var(--accent-primary);
            color: white;
            font-weight: 600;
        }
        
        .empty-chip {
            color: var(--text-muted);
            font-size: 0.65rem;
            font-style: italic;
        }
        
        .visuals-selected-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 0.5rem;
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .style-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .style-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .style-option:hover {
            border-color: rgba(139, 92, 246, 0.4);
        }
        
        .style-option input[type="radio"] {
            accent-color: var(--accent-primary);
        }
        
        .style-option input[type="radio"]:checked + .style-option-label {
            color: var(--accent-primary);
        }
        
        .style-option-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        .visuals-generate-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
        }
        
        .generate-vision-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            font-size: 0.85rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .generate-vision-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
        }
        
        .generate-vision-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .generate-vision-btn.loading .generate-icon {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .generate-status {
            font-size: 0.65rem;
            color: var(--text-muted);
            min-height: 1.2em;
        }
        
        .generate-status.error {
            color: #ef4444;
        }
        
        .generate-status.success {
            color: #10b981;
        }
        
        .visuals-gallery {
            min-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .visuals-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: var(--text-muted);
            text-align: center;
        }
        
        .visuals-placeholder-icon {
            font-size: 2.5rem;
            margin-bottom: 0.75rem;
            opacity: 0.5;
        }
        
        .visuals-placeholder p {
            font-size: 0.7rem;
            max-width: 250px;
            line-height: 1.5;
        }
        
        .vision-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
        }
        
        .vision-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: rgba(139, 92, 246, 0.1);
            border-bottom: 1px solid var(--border);
        }
        
        .vision-archetypes {
            display: flex;
            gap: 0.3rem;
        }
        
        .vision-archetype-tag {
            padding: 0.2rem 0.5rem;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 12px;
            font-size: 0.55rem;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .vision-style-tag {
            font-size: 0.6rem;
            color: var(--text-muted);
        }
        
        .vision-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.2rem;
        }
        
        .vision-model-tag {
            font-size: 0.5rem;
            color: var(--accent-primary);
            text-transform: capitalize;
        }
        
        .vision-image-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .vision-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .vision-prompt {
            padding: 0.75rem 1rem;
            font-size: 0.6rem;
            color: var(--text-muted);
            line-height: 1.5;
            border-top: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }
        
        .vision-actions {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-top: 1px solid var(--border);
        }
        
        .vision-action-btn {
            padding: 0.35rem 0.75rem;
            font-size: 0.65rem;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .vision-action-btn.save-btn {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(16, 185, 129, 0.2) 100%);
            border-color: rgba(34, 197, 94, 0.4);
            color: #22c55e;
        }
        
        .vision-action-btn.save-btn:hover {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(16, 185, 129, 0.3) 100%);
            border-color: rgba(34, 197, 94, 0.6);
        }
        
        .vision-action-btn:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 0.5);
        }
        
        .gallery-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .gallery-action-btn {
            padding: 0.5rem 1rem;
            font-size: 0.7rem;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(16, 185, 129, 0.2) 100%);
            border: 1px solid rgba(34, 197, 94, 0.4);
            border-radius: 8px;
            color: #22c55e;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .gallery-action-btn:hover {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(16, 185, 129, 0.3) 100%);
            border-color: rgba(34, 197, 94, 0.6);
            transform: translateY(-1px);
        }
        
        .gallery-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Model Selection */
        .visuals-model-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid var(--border);
            padding: 0.75rem;
        }
        
        .model-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .model-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .model-option:hover {
            border-color: rgba(139, 92, 246, 0.4);
            background: rgba(139, 92, 246, 0.1);
        }
        
        .model-option input[type="radio"] {
            accent-color: var(--accent-primary);
        }
        
        .model-option input[type="radio"]:checked + .model-option-content .model-name {
            color: var(--accent-primary);
        }
        
        .model-option-content {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }
        
        .model-name {
            font-size: 0.7rem;
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .model-desc {
            font-size: 0.55rem;
            color: var(--text-muted);
        }
        
        /* Semantic Bridges Section */
        .bridges-list {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .bridge-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }
        
        .bridge-item:hover {
            border-color: rgba(139, 92, 246, 0.3);
            background: rgba(139, 92, 246, 0.1);
        }
        
        .bridge-descriptor {
            font-size: 0.7rem;
            color: var(--text-primary);
            flex: 1;
        }
        
        .bridge-archetypes {
            display: flex;
            gap: 0.25rem;
        }
        
        .bridge-archetype-tag {
            font-size: 0.5rem;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            background: rgba(139, 92, 246, 0.2);
            color: var(--panel-purple-text);
        }
        
        .bridge-strength {
            font-size: 0.6rem;
            color: var(--accent-secondary);
            font-weight: 500;
        }
        
        /* Geodesic Distance Matrix */
        .geodesic-container {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
            justify-content: center;
        }
        
        .geodesic-matrix-wrapper {
            flex: 0 0 auto;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .geodesic-labels {
            position: absolute;
            font-size: 0.5rem;
            color: var(--text-muted);
        }
        
        #geodesicCanvas {
            width: 100%;
            height: 200px;
            border-radius: 6px;
        }
        
        .geodesic-stats {
            width: 140px;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        
        .geodesic-stat {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.6rem;
            text-align: center;
            border: 1px solid var(--border);
            transition: all 0.2s ease;
        }
        
        .geodesic-stat:hover {
            border-color: rgba(139, 92, 246, 0.3);
        }
        
        .geodesic-stat-value {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-secondary);
            word-break: break-all;
        }
        
        .geodesic-stat-label {
            font-size: 0.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 0.2rem;
        }
        
        .geodesic-color-scale {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-top: 0.4rem;
            font-size: 0.5rem;
            color: var(--text-muted);
            width: 100%;
            max-width: 200px;
        }
        
        .geodesic-scale-bar {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #14b8a6, #3b82f6, #8b5cf6, #1e1b4b);
        }

        /* Archetype Cards */
        .archetypes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 0.75rem;
            overflow-y: auto;
            padding: 1rem;
            padding-right: 0.5rem;
            position: relative;
            min-height: 400px;
            height: 100%;
        }
        
        .archetype-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--radius);
            padding: 1rem;
            border-left: 3px solid;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            border-color: var(--panel-purple-text);
        }
        
        .archetype-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(194, 166, 254, 0.1);
            border-color: #d4bfff;
        }
        
        .archetype-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }
        
        .archetype-name {
            font-weight: 300;
            font-size: 0.85rem;
            color: var(--panel-purple-text);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }
        
        .archetype-count {
            background: var(--panel-purple-text);
            color: var(--bg-primary);
            padding: 0.15rem 0.45rem;
            border-radius: 10px;
            font-size: 0.55rem;
            font-weight: 500;
        }
        
        .descriptor-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }
        
        .descriptor-tag {
            background: rgba(194, 166, 254, 0.08);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.65rem;
            color: var(--text-secondary);
            border: 1px solid var(--panel-purple-border);
            transition: all var(--transition);
        }
        
        .descriptor-tag:hover {
            background: rgba(194, 166, 254, 0.15);
            border-color: var(--panel-purple-text);
            color: var(--text-primary);
        }
        
        .descriptor-tag.more {
            background: transparent;
            color: var(--text-muted);
            border-style: dashed;
        }
        
        /* Cluster Visualization */
        .cluster-viz-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 1rem;
        }
        
        .cluster-canvas-container {
            flex: 1;
            background: var(--bg-primary);
            border-radius: var(--radius);
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border);
        }
        
        #clusterCanvas {
            width: 100%;
            height: 100%;
        }
        
        .cluster-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            padding: 0.65rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            margin-top: 0.6rem;
            max-height: 70px;
            overflow-y: auto;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            color: var(--text-muted);
            padding: 3rem 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .empty-state-icon {
            width: 250px;
            height: 250px;
            margin: 0 auto 2rem;
            position: relative;
        }
        
        .spiral-container {
            width: 250px;
            height: 250px;
            position: relative;
        }
        
        .spiral-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--accent-primary);
            box-shadow: 0 0 6px var(--accent-primary);
        }
        
        /* Elegant comet-like trail effect */
        .spiral-particle-trail {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            will-change: transform, opacity;
        }
        
        @keyframes spiralOrbit {
            0% { transform: rotate(0deg) translateX(var(--orbit-radius)) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(var(--orbit-radius)) rotate(-360deg); }
        }
        
        @keyframes breathe {
            0%, 100% { opacity: var(--base-opacity); filter: blur(var(--base-blur)); }
            50% { opacity: calc(var(--base-opacity) * 1.4); filter: blur(calc(var(--base-blur) * 0.7)); }
        }
        
        @keyframes spiralPulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        
        .spiral-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin: -8px 0 0 -8px;
            background: var(--accent-secondary);
            border-radius: 50%;
            box-shadow: 0 0 20px var(--accent-secondary), 0 0 40px var(--accent-primary);
            animation: spiralPulse 2s ease-in-out infinite;
        }
        
        .empty-state-text {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(120deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-top: 1rem;
        }
        
        /* Export Section */
        .export-group {
            display: flex;
            gap: 0.5rem;
            padding: 0.65rem 1rem;
            border-top: 1px solid var(--border);
            background: var(--bg-tertiary);
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { 
            background: var(--border); 
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover { background: var(--border-hover); }
        
        /* Responsive */
        @media (max-width: 1100px) {
            .main-grid { grid-template-columns: 1fr 1fr; }
            .panel.panel-results { grid-column: span 2; }
        }
        
        @media (max-width: 768px) {
            .main-grid { grid-template-columns: 1fr; height: auto; }
            .panel { min-height: 400px; }
            .panel.panel-results { grid-column: span 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="title-container">
                <div class="title">E G R E G O R E</div>
                <div class="drip-container">
                    <span class="drip"></span>
                    <span class="drip"></span>
                    <span class="drip"></span>
                    <span class="drip"></span>
                    <span class="drip"></span>
                    <span class="drip"></span>
                    <span class="drip"></span>
                    <span class="drip"></span>
                </div>
            </div>
            <div class="subtitle">Archetype Builder</div>
            <div class="header-controls">
                <div class="header-control-group">
                    <label for="outputLanguage">Lang</label>
                    <select id="outputLanguage">
                        <option value="english">EN</option>
                        <option value="french">FR</option>
                        <option value="spanish">ES</option>
                        <option value="german">DE</option>
                    </select>
                </div>
            </div>
            <div class="connection-badge" id="connectionBadge" onclick="forceReconnect()">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Disconnected</span>
            </div>
        </header>
        
        <div class="main-grid">
            <!-- Left Panel: Data Sources (Burnt Orange) -->
            <div class="panel panel-sources">
                <div class="panel-header">
                    Data Sources
                    <button class="btn btn-danger btn-sm" onclick="clearCorpus()">Clear</button>
                </div>
                
                <div class="tabs">
                    <div class="tab active" onclick="switchTab('text')">Text</div>
                    <div class="tab" onclick="switchTab('pdf')">PDF</div>
                    <div class="tab" onclick="switchTab('images')">Images</div>
                </div>
                
                <div class="panel-content">
                    <!-- Corpus Stats -->
                    <div class="corpus-stats">
                        <div class="stat-card">
                            <div class="stat-value" id="pdfCount">0</div>
                            <div class="stat-label">PDFs</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="imageCount">0</div>
                            <div class="stat-label">Images</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="textCount">0</div>
                            <div class="stat-label">Texts</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="chunkCount">0</div>
                            <div class="stat-label">Chunks</div>
                        </div>
                    </div>
                    
                    <!-- Text Input Tab -->
                    <div id="tab-text" class="tab-content active">
                        <div class="input-group">
                            <label class="input-label">Text content</label>
                            <textarea id="textInput" placeholder="Paste or type text here..." oninput="previewChunks()"></textarea>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Source label</label>
                            <input type="text" id="textSource" value="manual" placeholder="Source name">
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Chunking</label>
                            <select id="textChunking" onchange="updateChunkingParams('text')">
                                <option value="paragraph">Paragraph</option>
                                <option value="sentence">Sentence</option>
                                <option value="sliding">Sliding window</option>
                                <option value="none">None (whole text)</option>
                            </select>
                        </div>
                        
                        <!-- Paragraph params -->
                        <div id="textParams-paragraph" class="chunk-params">
                            <div class="config-grid">
                                <div class="input-group">
                                    <label class="input-label">Min length
                                        <span class="info-btn">?
                                            <span class="info-tooltip">Minimum number of <strong>characters</strong> for a chunk. Paragraphs shorter than this will be merged with the next one.</span>
                                        </span>
                                    </label>
                                    <input type="number" id="textParaMinLen" value="50" min="10" max="500" oninput="previewChunks()">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Max length
                                        <span class="info-btn">?
                                            <span class="info-tooltip">Maximum number of <strong>characters</strong> per chunk. Longer paragraphs will start a new chunk.</span>
                                        </span>
                                    </label>
                                    <input type="number" id="textParaMaxLen" value="1000" min="100" max="5000" oninput="previewChunks()">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sentence params -->
                        <div id="textParams-sentence" class="chunk-params" style="display:none;">
                            <div class="config-grid">
                                <div class="input-group">
                                    <label class="input-label">Sentences/chunk</label>
                                    <input type="number" id="textSentPerChunk" value="5" min="1" max="20" oninput="previewChunks()">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Overlap sentences</label>
                                    <input type="number" id="textSentOverlap" value="1" min="0" max="10" oninput="previewChunks()">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sliding window params -->
                        <div id="textParams-sliding" class="chunk-params" style="display:none;">
                            <div class="config-grid">
                                <div class="input-group">
                                    <label class="input-label">Window size</label>
                                    <input type="number" id="textWindowSize" value="512" min="100" max="2000" oninput="previewChunks()">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Stride</label>
                                    <input type="number" id="textStride" value="256" min="50" max="1000" oninput="previewChunks()">
                                </div>
                            </div>
                        </div>
                        
                        <div class="chunk-preview" id="chunkPreview" style="display:none;">
                            <span>Preview: <strong id="previewCount">0</strong> chunks</span>
                        </div>
                        
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="addText()">Add Text</button>
                        </div>
                    </div>
                    
                    <!-- PDF Input Tab -->
                    <div id="tab-pdf" class="tab-content">
                        <div class="input-group">
                            <label class="input-label">Select PDF Files or Folder</label>
                            <div class="file-buttons">
                                <button class="btn btn-secondary" onclick="document.getElementById('pdfFileInput').click()">
                                    Select PDFs
                                </button>
                                <button class="btn btn-secondary" onclick="document.getElementById('pdfFolderInput').click()">
                                    Select Folder
                                </button>
                                <input type="file" id="pdfFileInput" accept=".pdf" multiple style="display:none" onchange="handlePDFFiles(this.files)">
                                <input type="file" id="pdfFolderInput" webkitdirectory directory style="display:none" onchange="handlePDFFolder(this.files)">
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Or enter folder path manually</label>
                            <div class="input-row">
                                <input type="text" id="pdfPath" placeholder="C:/path/to/pdfs">
                                <button class="btn btn-primary" onclick="scanPDFs()">Scan</button>
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Chunking Method</label>
                            <select id="pdfChunking" onchange="updateChunkingParams('pdf')">
                                <option value="paragraph">Paragraph</option>
                                <option value="sentence">Sentence</option>
                                <option value="sliding">Sliding window</option>
                                <option value="page">By page</option>
                            </select>
                        </div>
                        
                        <!-- Paragraph params -->
                        <div id="pdfParams-paragraph" class="chunk-params">
                            <div class="config-grid">
                                <div class="input-group">
                                    <label class="input-label">Min length
                                        <span class="info-btn">?
                                            <span class="info-tooltip">Minimum number of <strong>characters</strong> for a chunk. Paragraphs shorter than this will be merged with the next one.</span>
                                        </span>
                                    </label>
                                    <input type="number" id="pdfParaMinLen" value="50" min="10" max="500">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Max length
                                        <span class="info-btn">?
                                            <span class="info-tooltip">Maximum number of <strong>characters</strong> per chunk. Longer paragraphs will start a new chunk.</span>
                                        </span>
                                    </label>
                                    <input type="number" id="pdfParaMaxLen" value="1000" min="100" max="5000">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sentence params -->
                        <div id="pdfParams-sentence" class="chunk-params" style="display:none;">
                            <div class="config-grid">
                                <div class="input-group">
                                    <label class="input-label">Sentences/chunk</label>
                                    <input type="number" id="pdfSentPerChunk" value="5" min="1" max="20">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Overlap sentences</label>
                                    <input type="number" id="pdfSentOverlap" value="1" min="0" max="10">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sliding window params -->
                        <div id="pdfParams-sliding" class="chunk-params" style="display:none;">
                            <div class="config-grid">
                                <div class="input-group">
                                    <label class="input-label">Window size</label>
                                    <input type="number" id="pdfWindowSize" value="512" min="100" max="2000">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Stride</label>
                                    <input type="number" id="pdfStride" value="256" min="50" max="1000">
                                </div>
                            </div>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="pdfRecursive" checked>
                            <label for="pdfRecursive">Scan subfolders</label>
                        </div>
                    </div>
                    
                    <!-- Images Input Tab -->
                    <div id="tab-images" class="tab-content">
                        <div class="input-group">
                            <label class="input-label">Select Image Files or Folder</label>
                            <div class="file-buttons">
                                <button class="btn btn-secondary" onclick="document.getElementById('imageFileInput').click()">
                                    Select Images
                                </button>
                                <button class="btn btn-secondary" onclick="document.getElementById('imageFolderInput').click()">
                                    Select Folder
                                </button>
                                <input type="file" id="imageFileInput" accept="image/*" multiple style="display:none" onchange="handleImageFiles(this.files)">
                                <input type="file" id="imageFolderInput" webkitdirectory directory style="display:none" onchange="handleImageFolder(this.files)">
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Or enter folder path manually</label>
                            <div class="input-row">
                                <input type="text" id="imagePath" placeholder="C:/path/to/images">
                                <button class="btn btn-primary" onclick="scanImages()">Scan</button>
                            </div>
                        </div>
                        
                        <div class="config-grid">
                            <div class="input-group">
                                <label class="input-label">Max images</label>
                                <input type="number" id="maxImages" value="500" min="10" max="5000">
                            </div>
                            <div></div>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="imageRecursive" checked>
                            <label for="imageRecursive">Scan subfolders</label>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="describeImages" checked>
                            <label for="describeImages">Describe images</label>
                        </div>
                        
                        <div class="input-group" style="margin-top: 8px;">
                            <label class="input-label">Description method</label>
                            <select id="imageDescribeMethod" class="select-input" style="width: 100%;">
                                <option value="semantic" selected>Semantic (CLIP + LLM) - Fast</option>
                                <option value="vision">Vision LLM - Slow but detailed</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Document Board -->
                    <div class="doc-board" id="docBoard">
                        <div class="doc-section" id="pdfSection" style="display:none;">
                            <div class="doc-section-header">
                                <div class="doc-section-title">PDFs</div>
                                <span id="pdfSectionCount">0 files</span>
                            </div>
                            <div class="doc-list" id="pdfList"></div>
                        </div>
                        
                        <div class="doc-section" id="imageSection" style="display:none;">
                            <div class="doc-section-header">
                                <div class="doc-section-title">Images</div>
                                <span id="imageSectionCount">0 files</span>
                            </div>
                            <div class="image-grid" id="imageGrid"></div>
                        </div>
                        
                        <div class="doc-section" id="textSection" style="display:none;">
                            <div class="doc-section-header">
                                <div class="doc-section-title">Text Sources</div>
                                <span id="textSectionCount">0 items</span>
                            </div>
                            <div class="doc-list" id="textList"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Center Panel: Config + Progress (Turquoise) -->
            <div class="panel panel-config">
                <div class="panel-header">
                    Builder Configuration
                    <span id="jobStatus" style="font-size: 0.65rem; color: var(--text-secondary);"></span>
                </div>
                <div class="panel-content" style="padding: 0.75rem;">
                    <!-- Mining Config -->
                    <div class="config-compact">
                        <div class="input-group">
                            <label class="input-label">Mining Mode</label>
                            <select id="miningMode" onchange="toggleFilters()">
                                <option value="exploratory">Exploratory (Discover Archetypes)</option>
                                <option value="directional">Directional (Apply Filters)</option>
                            </select>
                        </div>
                        
                        <div class="input-group" id="filtersGroup" style="display: none;">
                            <label class="input-label">Filters (comma-separated)</label>
                            <input type="text" id="filters" placeholder="e.g. North, South, East, West" value="North, South, East, West">
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Embedder Model</label>
                            <select id="embedder">
                                <option value="cloudflare-large">Cloudflare BGE-Large (1024d)</option>
                                <option value="cloudflare">Cloudflare BGE-Base (768d, fast)</option>
                                <option value="qwen3">Local Qwen3</option>
                                <option value="sentence-transformer">Sentence Transformer</option>
                            </select>
                        </div>
                        
                        <div class="config-grid">
                            <div class="input-group">
                                <label class="input-label">K Neighbors
                                    <span class="info-btn">?
                                        <span class="info-tooltip">Number of nearest neighbors for UMAP graph construction. Higher = more global structure preserved. Lower = finer local detail. Try 10-30.</span>
                                    </span>
                                </label>
                                <input type="number" id="kNeighbors" value="15" min="3" max="50">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Min Cluster
                                    <span class="info-btn">?
                                        <span class="info-tooltip">Minimum points to form a cluster. Smaller = more clusters (including tiny ones). Larger = fewer, denser clusters. Try 3-10.</span>
                                    </span>
                                </label>
                                <input type="number" id="minCluster" value="3" min="2" max="20">
                            </div>
                        </div>
                        
                        <div class="config-grid">
                            <div class="input-group">
                                <label class="input-label">Resolution
                                    <span class="info-btn">?
                                        <span class="info-tooltip">Louvain clustering resolution. Higher = more, smaller clusters. Lower = fewer, larger clusters. 1.0 is balanced. Try 0.5-2.0.</span>
                                    </span>
                                </label>
                                <input type="number" id="resolution" value="1.0" min="0.1" max="3.0" step="0.1">
                            </div>
                            <div class="checkbox-group" style="margin-top: 1.25rem;">
                                <input type="checkbox" id="useLLM" checked>
                                <label for="useLLM">LLM Refinement</label>
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">LLM Model</label>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <select id="llmModel" style="flex: 1;">
                                    <option value="@cf/meta/llama-3.1-8b-instruct">Llama 3.1 8B (default)</option>
                                    <option value="@cf/meta/llama-3.3-70b-instruct-fp8-fast">Llama 3.3 70B (quality)</option>
                                    <option value="@hf/google/gemma-7b-it">Google Gemma 7B</option>
                                </select>
                                <div style="display: flex; align-items: center; gap: 0.25rem;">
                                    <label style="font-size: 0.6rem; color: var(--text-muted);">T</label>
                                    <input type="number" id="llmTemperature" value="0.7" min="0" max="1.5" step="0.1" 
                                           style="width: 45px; padding: 0.35rem; font-size: 0.7rem; text-align: center;
                                                  background: var(--bg-primary); border: 1px solid var(--border); 
                                                  border-radius: 4px; color: var(--text-primary);">
                                </div>
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">Semantic Spread</label>
                            <div class="radio-group">
                                <label class="radio-option">
                                    <input type="radio" name="semanticSpread" value="0.15" checked>
                                    <span>Focused</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="semanticSpread" value="0.5">
                                    <span>Divergent</span>
                                </label>
                            </div>
                        </div>
                        
                        <button class="btn btn-primary" style="width: 100%; margin-top: 0.75rem; padding: 0.75rem;" onclick="startMining()" id="mineBtn">
                            Start Building
                        </button>
                    </div>
                    
                    <!-- Progress Section -->
                    <div class="progress-section">
                        <div class="section-label">Pipeline Progress</div>
                        <div class="pipeline-stages">
                            <div class="stage" title="Initialize"></div>
                            <div class="stage" title="Embed"></div>
                            <div class="stage" title="Graph"></div>
                            <div class="stage" title="Cluster"></div>
                            <div class="stage" title="Concepts"></div>
                            <div class="stage" title="LLM"></div>
                        </div>
                        
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="progressBar"></div>
                        </div>
                        <div class="progress-stage" id="progressStage">Ready</div>
                    </div>
                    
                    <div class="log-container" id="logContainer">
                        <div class="log-entry info">Add data sources and click Start Mining</div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel: Results (Purple Pastel) -->
            <div class="panel panel-results">
                <canvas id="spectralCanvas" class="spectral-canvas"></canvas>
                <div class="panel-header">
                    Results
                    <span id="archetypeCount" style="font-size: 0.65rem; color: var(--text-secondary);"></span>
                </div>
                
                <div class="results-tabs">
                    <div class="results-tab active" onclick="switchResultsTab('archetypes')">Archetypes</div>
                    <div class="results-tab" onclick="switchResultsTab('clusters')">Clusters</div>
                    <div class="results-tab" onclick="switchResultsTab('metrics')">Metrics</div>
                    <div class="results-tab" onclick="switchResultsTab('topology')">Topology</div>
                    <div class="results-tab" onclick="switchResultsTab('visuals')">Visuals</div>
                </div>
                
                <div class="panel-content" style="padding: 0.75rem;">
                    <!-- Archetypes Tab -->
                    <div id="results-archetypes" class="results-content active">
                        <div class="archetypes-grid" id="archetypesGrid">
                            <div class="empty-state">
                                <div class="empty-state-icon">
                                    <div class="spiral-container" id="spiralContainer">
                                        <div class="spiral-center"></div>
                                        <!-- Particles generated by JS -->
                                    </div>
                                </div>
                                <p class="empty-state-text">Create Your Egregore!</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Clusters Tab -->
                    <div id="results-clusters" class="results-content">
                        <div class="cluster-stats">
                            <div class="cluster-stat">
                                <span>Nodes:</span>
                                <span class="cluster-stat-value" id="clusterNodes">0</span>
                            </div>
                            <div class="cluster-stat">
                                <span>Clusters:</span>
                                <span class="cluster-stat-value" id="clusterCount">0</span>
                            </div>
                            <div class="cluster-stat">
                                <span>Edges:</span>
                                <span class="cluster-stat-value" id="clusterEdges">0</span>
                            </div>
                        </div>
                        <div class="cluster-viz-container">
                            <div class="cluster-canvas-container">
                                <canvas id="clusterCanvas"></canvas>
                            </div>
                            <div class="cluster-legend" id="clusterLegend"></div>
                        </div>
                    </div>
                    
                    <!-- Metrics Tab - Creative Constellation Visualization -->
                    <div id="results-metrics" class="results-content">
                        <div class="metrics-container">
                            <!-- Quality Score Hero -->
                            <div class="quality-hero">
                                <div class="quality-ring">
                                    <svg width="70" height="70" viewBox="0 0 70 70">
                                        <defs>
                                            <linearGradient id="qualityGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                <stop offset="0%" stop-color="#8b5cf6"/>
                                                <stop offset="50%" stop-color="#a78bfa"/>
                                                <stop offset="100%" stop-color="#c4b5fd"/>
                                            </linearGradient>
                                        </defs>
                                        <circle class="quality-ring-bg" cx="35" cy="35" r="28" fill="none" stroke-width="6"/>
                                        <circle class="quality-ring-fill" id="qualityRingFill" cx="35" cy="35" r="28" fill="none" stroke-width="6" 
                                                stroke-dasharray="175.9" stroke-dashoffset="175.9"/>
                                    </svg>
                                    <div class="quality-value" id="qualityScore"></div>
                                </div>
                                <div class="quality-details">
                                    <div class="quality-stat">
                                        <div class="quality-stat-value" id="metricCoherence"></div>
                                        <div class="quality-stat-label">Coherence</div>
                                    </div>
                                    <div class="quality-stat">
                                        <div class="quality-stat-value" id="metricSeparation"></div>
                                        <div class="quality-stat-label">Separation</div>
                                    </div>
                                    <div class="quality-stat">
                                        <div class="quality-stat-value" id="metricFocus"></div>
                                        <div class="quality-stat-label">Focus</div>
                                    </div>
                                    <div class="quality-stat">
                                        <div class="quality-stat-value" id="metricBalance"></div>
                                        <div class="quality-stat-label">Balance</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- 3D Embedding Space + Similarity Matrix -->
                            <div class="constellation-container">
                                <div class="constellation-canvas-wrapper">
                                    <div id="embedding3DContainer">
                                        <div class="embedding3d-hint"> Drag to rotate  Scroll to zoom</div>
                                        <div class="embedding3d-legend" id="embedding3DLegend"></div>
                                    </div>
                                </div>
                                <div class="similarity-panel">
                                    <div class="similarity-title">Inter-Archetype Affinity</div>
                                    <div class="similarity-canvas-wrapper">
                                        <canvas id="similarityMatrix"></canvas>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Per-Archetype Metric Cards -->
                            <div class="archetype-metrics-grid" id="archetypeMetricsGrid"></div>
                        </div>
                    </div>
                    
                    <!-- Topology Tab - Gravitational Fields, Gradient Flow, Topology Metrics -->
                    <div id="results-topology" class="results-content">
                        <div class="topology-container">
                            
                            <!-- Topology Metrics Overview -->
                            <div class="gravity-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Topology Metrics</div>
                                    <div class="topology-section-subtitle">Structural Properties</div>
                                </div>
                                <div class="topology-metrics-grid" id="topologyMetricsGrid">
                                    <div class="topology-metric-card">
                                        <div class="metric-tooltip">
                                            <div class="metric-tooltip-title">Total Mass</div>
                                            Total number of descriptors across all archetypes. Higher mass = richer semantic space with more conceptual density.
                                        </div>
                                        <div class="topology-metric-value" id="topoTotalMass"></div>
                                        <div class="topology-metric-label">Total Mass</div>
                                        <div class="topology-metric-sublabel"> descriptors</div>
                                    </div>
                                    <div class="topology-metric-card">
                                        <div class="metric-tooltip">
                                            <div class="metric-tooltip-title">Curvature</div>
                                            How "warped" the meaning space is. High curvature means descriptors are unevenly distributed around centroids. Low = uniform spherical clusters.
                                        </div>
                                        <div class="topology-metric-value" id="topoMeanCurvature"></div>
                                        <div class="topology-metric-label">Curvature</div>
                                        <div class="topology-metric-sublabel">meaning warp</div>
                                    </div>
                                    <div class="topology-metric-card">
                                        <div class="metric-tooltip">
                                            <div class="metric-tooltip-title">Connectivity</div>
                                            Average similarity between different archetypes. High = archetypes overlap and meanings blend. Low = well-separated distinct concepts.
                                        </div>
                                        <div class="topology-metric-value" id="topoConnectivity"></div>
                                        <div class="topology-metric-label">Connectivity</div>
                                        <div class="topology-metric-sublabel">graph density</div>
                                    </div>
                                    <div class="topology-metric-card">
                                        <div class="metric-tooltip">
                                            <div class="metric-tooltip-title">Semantic Bridges</div>
                                            Descriptors that connect two archetypes. These are conceptual "portals"  words that carry meaning across domains.
                                        </div>
                                        <div class="topology-metric-value" id="topoNumBridges"></div>
                                        <div class="topology-metric-label">Bridges</div>
                                        <div class="topology-metric-sublabel">semantic portals</div>
                                    </div>
                                    <div class="topology-metric-card">
                                        <div class="metric-tooltip">
                                            <div class="metric-tooltip-title">Average Path Length</div>
                                            Mean geodesic distance between archetype centroids. Small = compact space. Large = sprawling, diverse conceptual territory.
                                        </div>
                                        <div class="topology-metric-value" id="topoAvgGeodesic"></div>
                                        <div class="topology-metric-label">Avg Path</div>
                                        <div class="topology-metric-sublabel">geodesic dist</div>
                                    </div>
                                    <div class="topology-metric-card">
                                        <div class="metric-tooltip">
                                            <div class="metric-tooltip-title">Diameter</div>
                                            Maximum distance between any two archetypes. Defines the "size" of your conceptual universe. The farthest pair are your most opposed concepts.
                                        </div>
                                        <div class="topology-metric-value" id="topoDiameter"></div>
                                        <div class="topology-metric-label">Diameter</div>
                                        <div class="topology-metric-sublabel">max distance</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Gravitational Field Visualization -->
                            <div class="gravity-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Gravitational Field</div>
                                    <div class="topology-section-subtitle">Archetype attraction wells</div>
                                </div>
                                <div class="gravity-canvas-container">
                                    <canvas id="gravityCanvas"></canvas>
                                    <div class="gravity-legend">
                                        <span style="color: #a78bfa;"> Archetypes</span> &nbsp;
                                        <span style="color: #5eead4;"> Descriptors</span> &nbsp;
                                        <span style="color: rgba(139,92,246,0.3);"> Gravity wells</span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Gradient Flow Field -->
                            <div class="gravity-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Gradient Flow</div>
                                    <div class="topology-section-subtitle">Direction of meaning</div>
                                </div>
                                <div class="gradient-flow-container">
                                    <canvas id="gradientCanvas"></canvas>
                                </div>
                            </div>
                            
                            <!-- Semantic Bridges -->
                            <div class="gravity-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Semantic Bridges</div>
                                    <div class="topology-section-subtitle">Cross-archetype portals</div>
                                </div>
                                <div class="bridges-list" id="bridgesList">
                                    <div class="empty-state" style="padding: 1rem; min-height: auto;">
                                        <p style="color: var(--text-muted); font-size: 0.7rem;">Run builder to discover bridges</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Geodesic Distances -->
                            <div class="gravity-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Geodesic Distances</div>
                                    <div class="topology-section-subtitle">Shortest paths through meaning</div>
                                </div>
                                <div class="geodesic-container">
                                    <div class="geodesic-matrix-wrapper">
                                        <canvas id="geodesicCanvas"></canvas>
                                        <div class="geodesic-color-scale">
                                            <span>Close</span>
                                            <div class="geodesic-scale-bar"></div>
                                            <span>Far</span>
                                        </div>
                                    </div>
                                    <div class="geodesic-stats">
                                        <div class="geodesic-stat">
                                            <div class="geodesic-stat-label">Closest Pair</div>
                                            <div class="geodesic-stat-value" id="geoClosestPair" style="color: #14b8a6;"></div>
                                            <div class="geodesic-stat-value" id="geoMinDist" style="font-size: 0.7rem; opacity: 0.7;"></div>
                                        </div>
                                        <div class="geodesic-stat">
                                            <div class="geodesic-stat-label">Farthest Pair</div>
                                            <div class="geodesic-stat-value" id="geoFarthestPair" style="color: #8b5cf6;"></div>
                                            <div class="geodesic-stat-value" id="geoMaxDist" style="font-size: 0.7rem; opacity: 0.7;"></div>
                                        </div>
                                        <div class="geodesic-stat">
                                            <div class="geodesic-stat-label">Mean Distance</div>
                                            <div class="geodesic-stat-value" id="geoMeanDist"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                    
                    <!-- Visuals Tab - AI Generated Archetype Art -->
                    <div id="results-visuals" class="results-content">
                        <div class="visuals-container">
                            
                            <!-- API Key Configuration -->
                            <div class="visuals-config-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Gemini API</div>
                                    <div class="topology-section-subtitle">Google AI Studio</div>
                                </div>
                                <div class="api-key-row">
                                    <input type="password" id="geminiApiKey" class="api-key-input" placeholder="Enter your Gemini API key..." />
                                    <button class="btn btn-secondary btn-sm" onclick="toggleApiKeyVisibility()"></button>
                                    <button class="btn btn-primary btn-sm" onclick="saveApiKey()">Save</button>
                                </div>
                                <div class="api-key-hint">Get your key at <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a></div>
                            </div>
                            
                            <!-- Archetype Selection -->
                            <div class="visuals-selection-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Select Archetypes</div>
                                    <div class="topology-section-subtitle">Choose 2+ for interaction visualization</div>
                                </div>
                                <div class="archetype-chips" id="visualsArchetypeChips">
                                    <div class="empty-chip">Run builder to see archetypes</div>
                                </div>
                                <div class="visuals-selected-info">
                                    <span id="selectedArchetypesCount">0</span> selected
                                    <button class="btn btn-secondary btn-sm" onclick="clearArchetypeSelection()" id="clearSelectionBtn" style="display: none;">Clear</button>
                                </div>
                                <label class="bridge-option" style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-muted); cursor: pointer;">
                                    <input type="checkbox" id="enforceSemanticBridges" style="accent-color: var(--accent-mystic);" />
                                    <span> Enforce semantic bridges in prompt</span>
                                </label>
                            </div>
                            
                            <!-- Style Options -->
                            <div class="visuals-style-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Visual Style</div>
                                    <div class="topology-section-subtitle">Codex Seraphinianus inspired</div>
                                </div>
                                <div class="style-options">
                                    <label class="style-option">
                                        <input type="radio" name="visualStyle" value="botanical" checked />
                                        <span class="style-option-label"> Botanical</span>
                                    </label>
                                    <label class="style-option">
                                        <input type="radio" name="visualStyle" value="mechanical" />
                                        <span class="style-option-label"> Mechanical</span>
                                    </label>
                                    <label class="style-option">
                                        <input type="radio" name="visualStyle" value="anatomical" />
                                        <span class="style-option-label"> Anatomical</span>
                                    </label>
                                    <label class="style-option">
                                        <input type="radio" name="visualStyle" value="cosmological" />
                                        <span class="style-option-label"> Cosmological</span>
                                    </label>
                                    <label class="style-option">
                                        <input type="radio" name="visualStyle" value="elemental" />
                                        <span class="style-option-label"> Elemental</span>
                                    </label>
                                    <label class="style-option">
                                        <input type="radio" name="visualStyle" value="scalefree" />
                                        <span class="style-option-label"> Scale-free</span>
                                    </label>
                                    <label class="style-option">
                                        <input type="radio" name="visualStyle" value="creatures" />
                                        <span class="style-option-label"> Creatures</span>
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Model Selection -->
                            <div class="visuals-model-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">AI Model</div>
                                    <div class="topology-section-subtitle">Choose generation engine</div>
                                </div>
                                <div class="model-options">
                                    <label class="model-option">
                                        <input type="radio" name="imageModel" value="gemini-2.5-flash-image" checked />
                                        <span class="model-option-content">
                                            <span class="model-name">Gemini 2.5 Flash</span>
                                            <span class="model-desc">Fast, creative</span>
                                        </span>
                                    </label>
                                    <label class="model-option">
                                        <input type="radio" name="imageModel" value="gemini-3-pro-image-preview" />
                                        <span class="model-option-content">
                                            <span class="model-name">Gemini 3 Pro</span>
                                            <span class="model-desc">High quality</span>
                                        </span>
                                    </label>
                                    <label class="model-option">
                                        <input type="radio" name="imageModel" value="nano-banana-pro-preview" />
                                        <span class="model-option-content">
                                            <span class="model-name"> Nano Banana</span>
                                            <span class="model-desc">Experimental</span>
                                        </span>
                                    </label>
                                    <label class="model-option">
                                        <input type="radio" name="imageModel" value="imagen-4.0-generate-001" />
                                        <span class="model-option-content">
                                            <span class="model-name">Imagen 4</span>
                                            <span class="model-desc">Photorealistic</span>
                                        </span>
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Generate Button -->
                            <div class="visuals-generate-section">
                                <button class="btn btn-primary generate-vision-btn" id="generateVisionBtn" onclick="generateArchetypeVision()" disabled>
                                    <span class="generate-icon"></span>
                                    <span>Generate Vision</span>
                                </button>
                                <div class="generate-status" id="generateStatus"></div>
                            </div>
                            
                            <!-- Generated Image Display -->
                            <div class="visuals-gallery-section">
                                <div class="topology-section-header">
                                    <div class="topology-section-icon"></div>
                                    <div class="topology-section-title">Generated Visions</div>
                                    <div class="topology-section-subtitle">Archetype interactions visualized</div>
                                </div>
                                <div class="gallery-actions" id="galleryActions" style="display: none;">
                                    <button class="gallery-action-btn" onclick="downloadAllVisions()"> Save All Images</button>
                                    <button class="gallery-action-btn" onclick="clearAllVisions()" style="background: rgba(239, 68, 68, 0.15); border-color: rgba(239, 68, 68, 0.3); color: #ef4444;"> Clear All</button>
                                </div>
                                <div class="visuals-gallery" id="visualsGallery">
                                    <div class="visuals-placeholder">
                                        <div class="visuals-placeholder-icon"></div>
                                        <p>Select archetypes and generate to see their visual manifestation</p>
                                    </div>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                </div>
                
                <div class="export-group" id="exportGroup" style="display: none;">
                    <button class="btn btn-secondary btn-sm" onclick="exportJSON()">Export JSON</button>
                    <button class="btn btn-secondary btn-sm" onclick="copyToClipboard()">Copy</button>
                    <button class="btn btn-primary btn-sm" onclick="sendToExplorer()">Open in Explorer</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        console.log('=== EGREGORE SCRIPT LOADED ===');
        
        // Generate unique session ID for this browser tab
        // Use sessionStorage so each tab gets its own session
        let sessionId = sessionStorage.getItem('egregore_session_id');
        if (!sessionId) {
            sessionId = 'sess_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now().toString(36);
            sessionStorage.setItem('egregore_session_id', sessionId);
        }
        console.log('[Session] ID:', sessionId);
        
        let ws = null;
        let currentResults = null;
        let corpusData = { pdfs: [], images: [], texts: [], totalChunks: 0 };
        let clusterData = null;
        
        // Cluster colors
        const CLUSTER_COLORS = [
            '#8b5cf6', '#3b82f6', '#10b981', '#f59e0b', '#ef4444',
            '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1',
            '#14b8a6', '#eab308', '#a855f7', '#22c55e', '#0ea5e9'
        ];
        
        // Helper: Convert hex color to rgba
        function hexToRgba(hex, alpha) {
            // Handle shorthand (#abc) or full (#aabbcc) hex
            let r, g, b;
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else {
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Initialize spiral particle animation
        function initSpiralAnimation() {
            const container = document.getElementById('spiralContainer');
            if (!container) return;
            
            // Clear existing particles (except center)
            container.querySelectorAll('.spiral-particle, .spiral-particle-trail').forEach(p => p.remove());
            
            // Configuration
            const numLayers = 5;
            const trailLength = 8; // Smooth trail segments
            
            for (let layer = 0; layer < numLayers; layer++) {
                const baseRadius = 25 + layer * 22;
                const particlesInLayer = 5 + layer;
                const layerSpeed = 5 + layer * 2.5;
                const direction = layer % 2 === 0 ? 1 : -1;
                
                for (let i = 0; i < particlesInLayer; i++) {
                    const angleOffset = (i / particlesInLayer) * 360;
                    const baseSize = 4 + (numLayers - layer) * 0.8;
                    
                    // Color gradient from purple to cyan
                    const hue = 270 - layer * 25;
                    const particleColor = `hsl(${hue}, 75%, 65%)`;
                    
                    // Create smooth trailing segments (rendered back to front)
                    for (let t = trailLength - 1; t >= 0; t--) {
                        const trail = document.createElement('div');
                        trail.className = 'spiral-particle-trail';
                        
                        // Smooth exponential falloff for size and opacity
                        const progress = t / trailLength;
                        const trailSize = baseSize * (1 - progress * 0.6);
                        const trailOpacity = Math.pow(1 - progress, 1.5) * 0.9;
                        const trailBlur = progress * 3;
                        
                        trail.style.width = `${trailSize}px`;
                        trail.style.height = `${trailSize}px`;
                        trail.style.background = particleColor;
                        trail.style.boxShadow = `0 0 ${4 + (1 - progress) * 8}px ${particleColor}`;
                        trail.style.setProperty('--base-opacity', trailOpacity);
                        trail.style.setProperty('--base-blur', `${trailBlur}px`);
                        trail.style.opacity = trailOpacity;
                        trail.style.filter = `blur(${trailBlur}px)`;
                        
                        // Position at center
                        trail.style.left = `calc(50% - ${trailSize/2}px)`;
                        trail.style.top = `calc(50% - ${trailSize/2}px)`;
                        
                        // Orbit with angular offset for smooth trail
                        const trailAngleOffset = t * 4; // 4 degrees per segment
                        trail.style.setProperty('--orbit-radius', `${baseRadius}px`);
                        
                        const totalDelay = (-angleOffset - (direction * trailAngleOffset)) / 360 * layerSpeed;
                        trail.style.animation = `spiralOrbit ${layerSpeed}s linear infinite, breathe ${3 + layer * 0.5}s ease-in-out infinite`;
                        trail.style.animationDelay = `${totalDelay}s, ${t * 0.1}s`;
                        if (direction === -1) {
                            trail.style.animationDirection = 'reverse, normal';
                        }
                        
                        container.appendChild(trail);
                    }
                    
                    // Create bright lead particle
                    const particle = document.createElement('div');
                    particle.className = 'spiral-particle';
                    
                    particle.style.width = `${baseSize}px`;
                    particle.style.height = `${baseSize}px`;
                    particle.style.background = `hsl(${hue}, 85%, 75%)`;
                    particle.style.boxShadow = `0 0 ${8 + layer}px ${particleColor}, 0 0 ${15 + layer * 2}px ${particleColor}`;
                    
                    particle.style.left = `calc(50% - ${baseSize/2}px)`;
                    particle.style.top = `calc(50% - ${baseSize/2}px)`;
                    
                    particle.style.setProperty('--orbit-radius', `${baseRadius}px`);
                    particle.style.animation = `spiralOrbit ${layerSpeed}s linear infinite`;
                    particle.style.animationDelay = `${-angleOffset / 360 * layerSpeed}s`;
                    if (direction === -1) {
                        particle.style.animationDirection = 'reverse';
                    }
                    
                    container.appendChild(particle);
                }
            }
        }
        
        // Initialize spiral on load
        setTimeout(initSpiralAnimation, 100);
        
        // Toggle chunking params visibility
        function updateChunkingParams(prefix) {
            const method = document.getElementById(`${prefix}Chunking`).value;
            const methods = ['paragraph', 'sentence', 'sliding', 'page', 'none'];
            
            methods.forEach(m => {
                const el = document.getElementById(`${prefix}Params-${m}`);
                if (el) el.style.display = m === method ? 'block' : 'none';
            });
            
            // Update preview if on text tab
            if (prefix === 'text') previewChunks();
            
            // For PDFs, trigger rechunking if there are existing PDFs
            if (prefix === 'pdf' && corpusData.pdfs.length > 0) {
                rechunkPDFs();
            }
        }
        
        // Debounce timer for rechunking
        let rechunkTimeout = null;
        
        // Rechunk existing PDFs with new chunking parameters
        function rechunkPDFs() {
            // Debounce to avoid too many requests while user is adjusting
            if (rechunkTimeout) clearTimeout(rechunkTimeout);
            rechunkTimeout = setTimeout(() => {
                const config = getChunkingConfig('pdf');
                addLog(`Rechunking PDFs with ${config.method} method...`, 'info');
                
                ws.send(JSON.stringify({
                    type: 'rechunk_pdfs',
                    chunking: config.method,
                    chunk_params: config
                }));
            }, 500);
        }
        
        // Also add listeners for parameter inputs to trigger rechunking
        function setupChunkingListeners() {
            const pdfInputs = [
                'pdfParaMinLen', 'pdfParaMaxLen',
                'pdfSentPerChunk', 'pdfSentOverlap',
                'pdfWindowSize', 'pdfStride'
            ];
            
            pdfInputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => {
                        if (corpusData.pdfs.length > 0) rechunkPDFs();
                    });
                }
            });
        }
        
        // Call setup after DOM is ready
        document.addEventListener('DOMContentLoaded', setupChunkingListeners);
        
        // Get chunking config for a prefix (text or pdf)
        function getChunkingConfig(prefix) {
            const method = document.getElementById(`${prefix}Chunking`).value;
            const config = { method };
            
            if (method === 'paragraph') {
                config.min_length = parseInt(document.getElementById(`${prefix}ParaMinLen`).value);
                config.max_length = parseInt(document.getElementById(`${prefix}ParaMaxLen`).value);
            } else if (method === 'sentence') {
                config.sentences_per_chunk = parseInt(document.getElementById(`${prefix}SentPerChunk`).value);
                config.overlap_sentences = parseInt(document.getElementById(`${prefix}SentOverlap`).value);
            } else if (method === 'sliding') {
                config.window_size = parseInt(document.getElementById(`${prefix}WindowSize`).value);
                config.stride = parseInt(document.getElementById(`${prefix}Stride`).value);
            }
            
            return config;
        }
        
        // Client-side chunk preview (estimates)
        function previewChunks() {
            const text = document.getElementById('textInput').value;
            const previewEl = document.getElementById('chunkPreview');
            const countEl = document.getElementById('previewCount');
            
            if (!text.trim()) {
                previewEl.style.display = 'none';
                return;
            }
            
            const config = getChunkingConfig('text');
            let chunks = 0;
            
            if (config.method === 'none') {
                chunks = 1;
            } else if (config.method === 'paragraph') {
                // Estimate paragraph chunks
                const paras = text.split(/\n\s*\n/).filter(p => p.trim().length >= (config.min_length || 50));
                chunks = paras.length || 1;
            } else if (config.method === 'sentence') {
                // Estimate sentence chunks
                const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
                const perChunk = config.sentences_per_chunk || 5;
                const overlap = config.overlap_sentences || 1;
                if (sentences.length <= perChunk) {
                    chunks = 1;
                } else {
                    chunks = Math.ceil((sentences.length - overlap) / (perChunk - overlap));
                }
            } else if (config.method === 'sliding') {
                // Estimate sliding window chunks
                const windowSize = config.window_size || 512;
                const stride = config.stride || 256;
                chunks = Math.max(1, Math.ceil((text.length - windowSize) / stride) + 1);
            }
            
            countEl.textContent = chunks;
            previewEl.style.display = 'block';
        }
        
        function switchResultsTab(tabName) {
            document.querySelectorAll('.results-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.results-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`results-${tabName}`).classList.add('active');
            
            if (tabName === 'clusters' && clusterData) {
                setTimeout(() => drawClusterViz(), 100);
            }
            
            // Redraw metrics visualizations when switching to metrics tab
            if (tabName === 'metrics' && metricsData) {
                setTimeout(() => {
                    const { metrics, archetypeNames } = metricsData;
                    draw3DEmbeddings(metrics.embedding_coords || [], archetypeNames);
                    if (metrics.inter_similarity) {
                        drawSimilarityMatrix(metrics.inter_similarity, archetypeNames);
                    }
                }, 100);
            }
            
            // Draw topology visualizations when switching to topology tab
            if (tabName === 'topology' && metricsData) {
                setTimeout(() => {
                    const { metrics, archetypeNames } = metricsData;
                    drawTopologyVisualizations(metrics, archetypeNames);
                }, 100);
            }
            
            // Update visuals tab when switching to it
            if (tabName === 'visuals') {
                initVisualsTab();
                updateVisualsArchetypeChips();
            }
        }
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach((t, i) => {
                t.classList.toggle('active', 
                    (tabName === 'text' && i === 0) || 
                    (tabName === 'pdf' && i === 1) || 
                    (tabName === 'images' && i === 2));
            });
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
        }
        
        let reconnectAttempts = 0;
        const maxReconnectDelay = 30000; // Max 30 seconds between reconnects
        let reconnectTimeout = null;
        let clientPingInterval = null;
        
        function updateConnectionStatus(status, message) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            const badge = document.getElementById('connectionBadge');
            dot.classList.remove('connected', 'reconnecting');
            badge.classList.remove('connected');
            if (status === 'connected') {
                dot.classList.add('connected');
                badge.classList.add('connected');
            } else if (status === 'reconnecting') {
                dot.classList.add('reconnecting');
            }
            text.textContent = message;
        }
        
        function startClientPing() {
            // Client-side ping every 20s to keep Railway connection alive
            if (clientPingInterval) clearInterval(clientPingInterval);
            clientPingInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 20000);
        }
        
        function stopClientPing() {
            if (clientPingInterval) {
                clearInterval(clientPingInterval);
                clientPingInterval = null;
            }
        }
        
        function connect() {
            // Clear any pending reconnect
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
            
            ws.onopen = () => {
                reconnectAttempts = 0; // Reset on successful connection
                // Send session ID as first message
                ws.send(JSON.stringify({ type: 'init', session_id: sessionId }));
                updateConnectionStatus('connected', 'Connected');
                addLog('Connected to server', 'success');
                startClientPing();
            };
            
            ws.onclose = (event) => {
                stopClientPing();
                
                // Faster reconnect for first few attempts (Railway can be flaky)
                reconnectAttempts++;
                let delay;
                if (reconnectAttempts <= 3) {
                    delay = 500 * reconnectAttempts; // 500ms, 1s, 1.5s for first 3 attempts
                } else {
                    delay = Math.min(1000 * Math.pow(1.5, reconnectAttempts - 3), maxReconnectDelay);
                }
                
                console.log(`[WS] Connection closed (code: ${event.code}). Reconnecting in ${Math.round(delay/1000)}s... (attempt ${reconnectAttempts})`);
                
                // Show reconnecting status with countdown
                let remaining = Math.ceil(delay / 1000);
                updateConnectionStatus('reconnecting', `Reconnecting (${remaining}s)`);
                
                // Update countdown every second
                const countdownInterval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        updateConnectionStatus('reconnecting', `Reconnecting (${remaining}s)`);
                    } else {
                        clearInterval(countdownInterval);
                    }
                }, 1000);
                
                reconnectTimeout = setTimeout(() => {
                    clearInterval(countdownInterval);
                    connect();
                }, delay);
            };
            
            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
                // Don't show error in UI - onclose will handle reconnection
            };
            ws.onmessage = (e) => {
                try {
                    const msg = JSON.parse(e.data);
                    // Handle server ping silently
                    if (msg.type === 'ping') {
                        ws.send(JSON.stringify({ type: 'pong' }));
                        return;
                    }
                    console.log('[WS] Received message type:', msg.type);
                    handleMessage(msg);
                } catch(err) {
                    console.error('[WS] Parse error:', err, e.data);
                }
            };
        }
        
        function forceReconnect() {
            console.log('[WS] Force reconnect requested by user');
            // Close existing connection if any
            if (ws) {
                // Temporarily remove onclose handler to avoid double-reconnect
                ws.onclose = null;
                ws.close();
            }
            // Clear any pending reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            stopClientPing();
            // Reset attempt counter for fresh start
            reconnectAttempts = 0;
            updateConnectionStatus('reconnecting', 'Connecting...');
            // Small delay to ensure clean disconnect
            setTimeout(connect, 100);
        }
        
        function handleMessage(msg) {
            console.log('[handleMessage] Processing:', msg.type);
            switch (msg.type) {
                case 'init':
                    // Server may return a session ID (e.g., if it was generated server-side)
                    if (msg.session_id) {
                        sessionId = msg.session_id;
                        sessionStorage.setItem('egregore_session_id', sessionId);
                        console.log('[Session] Updated from server:', sessionId);
                    }
                    if (msg.corpus) updateFromServer(msg.corpus);
                    break;
                case 'corpus_updated':
                    updateFromServer(msg);
                    break;
                case 'corpus_cleared':
                    corpusData = { pdfs: [], images: [], texts: [], totalChunks: 0 };
                    updateDisplay();
                    addLog('Corpus cleared', 'info');
                    break;
                case 'pdf_scanned':
                    corpusData.pdfs.push(...msg.pdfs);
                    corpusData.totalChunks += msg.chunks;
                    updateDisplay();
                    addLog(`Added ${msg.pdfs.length} PDFs (${msg.chunks} chunks)`, 'success');
                    break;
                case 'rechunk_complete':
                    addLog(msg.message, 'success');
                    break;
                case 'images_scanned':
                    corpusData.images.push(...msg.images);
                    updateDisplay();
                    addLog(`Added ${msg.images.length} images`, 'success');
                    break;
                case 'text_added':
                    corpusData.texts.push(...msg.texts);
                    corpusData.totalChunks += msg.chunks;
                    updateDisplay();
                    addLog(`Added text (${msg.chunks} chunks)`, 'success');
                    break;
                case 'job_created':
                    document.getElementById('mineBtn').disabled = true;
                    document.getElementById('jobStatus').textContent = `Job: ${msg.job.id}`;
                    clearLogs();
                    resetStages();
                    break;
                case 'progress':
                    updateProgress(msg);
                    break;
                case 'job_completed':
                    console.log('=== JOB COMPLETED MESSAGE RECEIVED ===');
                    console.log('msg:', msg);
                    console.log('msg.result:', msg.result);
                    console.log('msg.result.archetypes:', msg.result?.archetypes);
                    document.getElementById('mineBtn').disabled = false;
                    currentResults = msg.result;
                    try {
                        displayResults(msg.result);
                        // Update visuals tab archetype chips
                        selectedArchetypesForVision = [];
                        updateVisualsArchetypeChips();
                    } catch(err) {
                        console.error('[displayResults] Error:', err);
                        addLog(' Error displaying results: ' + err.message, 'error');
                    }
                    addLog(' Mining completed!', 'success');
                    completeStages();
                    break;
                case 'job_failed':
                    document.getElementById('mineBtn').disabled = false;
                    addLog(` Error: ${msg.error}`, 'error');
                    errorStages();
                    break;
                case 'scan_progress':
                    addLog(msg.message, 'info');
                    break;
            }
        }
        
        function updateFromServer(data) {
            if (data.pdf_items) corpusData.pdfs = data.pdf_items;
            if (data.image_items) corpusData.images = data.image_items;
            if (data.text_items) corpusData.texts = data.text_items;
            if (data.chunks !== undefined) corpusData.totalChunks = data.chunks;
            updateDisplay();
        }
        
        function updateDisplay() {
            document.getElementById('pdfCount').textContent = corpusData.pdfs.length;
            document.getElementById('imageCount').textContent = corpusData.images.length;
            document.getElementById('textCount').textContent = corpusData.texts.length;
            document.getElementById('chunkCount').textContent = corpusData.totalChunks;
            
            // PDFs
            const pdfSection = document.getElementById('pdfSection');
            const pdfList = document.getElementById('pdfList');
            if (corpusData.pdfs.length > 0) {
                pdfSection.style.display = 'block';
                document.getElementById('pdfSectionCount').textContent = `${corpusData.pdfs.length} files`;
                pdfList.innerHTML = corpusData.pdfs.map((p, i) => `
                    <div class="doc-item">
                        <div class="doc-item-info">
                            <span class="doc-icon">PDF</span>
                            <span class="doc-item-name">${p.name}</span>
                            <span class="doc-item-meta">${p.pages || '?'}p, ${p.chunks || '?'}c</span>
                        </div>
                        <span class="doc-item-remove" onclick="removeItem('pdf', ${i})"></span>
                    </div>
                `).join('');
            } else pdfSection.style.display = 'none';
            
            // Images
            const imageSection = document.getElementById('imageSection');
            const imageGrid = document.getElementById('imageGrid');
            if (corpusData.images.length > 0) {
                imageSection.style.display = 'block';
                document.getElementById('imageSectionCount').textContent = `${corpusData.images.length} files`;
                const thumbs = corpusData.images.slice(0, 20).map(img => 
                    `<div class="image-thumb" title="${img.name}">${img.name.slice(0,6)}</div>`
                ).join('');
                const more = corpusData.images.length > 20 ? 
                    `<div class="image-thumb">+${corpusData.images.length - 20}</div>` : '';
                imageGrid.innerHTML = thumbs + more;
            } else imageSection.style.display = 'none';
            
            // Texts
            const textSection = document.getElementById('textSection');
            const textList = document.getElementById('textList');
            if (corpusData.texts.length > 0) {
                textSection.style.display = 'block';
                document.getElementById('textSectionCount').textContent = `${corpusData.texts.length} sources`;
                textList.innerHTML = corpusData.texts.map((t, i) => `
                    <div class="doc-item">
                        <div class="doc-item-info">
                            <span class="doc-icon">TXT</span>
                            <span class="doc-item-name">${t.source}</span>
                            <span class="doc-item-meta">${t.chunks || 1}c</span>
                        </div>
                        <span class="doc-item-remove" onclick="removeItem('text', ${i})"></span>
                    </div>
                `).join('');
            } else textSection.style.display = 'none';
        }
        
        function updateProgress(msg) {
            document.getElementById('progressBar').style.width = `${msg.progress * 100}%`;
            document.getElementById('progressStage').textContent = 
                msg.detail ? `${msg.stage}: ${msg.detail}` : msg.stage;
            if (msg.log) addLog(msg.log);
            
            const stageMap = {
                'Initializing': 0, 'Loading embedder': 0, 'Creating miner': 0,
                'Loading corpus': 1, 'Loading images': 1, 'Embedding': 1, 'Embedding complete': 1,
                'Building graph': 2, 'Graph built': 2,
                'Clustering': 3, 'Clusters found': 3,
                'Extracting concepts': 4,
                'LLM refinement': 5, 'LLM complete': 5
            };
            const idx = stageMap[msg.stage] ?? -1;
            document.querySelectorAll('.stage').forEach((s, i) => {
                s.classList.remove('active', 'complete');
                if (i < idx) s.classList.add('complete');
                else if (i === idx) s.classList.add('active');
            });
        }
        
        function resetStages() {
            document.querySelectorAll('.stage').forEach(s => 
                s.classList.remove('active', 'complete', 'error'));
        }
        
        function completeStages() {
            document.querySelectorAll('.stage').forEach(s => {
                s.classList.remove('active', 'error');
                s.classList.add('complete');
            });
        }
        
        function errorStages() {
            document.querySelectorAll('.stage').forEach(s => {
                if (s.classList.contains('active')) {
                    s.classList.remove('active');
                    s.classList.add('error');
                }
            });
        }
        
        function addLog(msg, type = '') {
            const container = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }
        
        function clearLogs() {
            document.getElementById('logContainer').innerHTML = '';
        }
        
        // Actions
        function addText() {
            const text = document.getElementById('textInput').value.trim();
            const source = document.getElementById('textSource').value || 'manual';
            if (!text) return;
            
            const chunkConfig = getChunkingConfig('text');
            
            ws.send(JSON.stringify({
                type: 'add_text',
                text: text,
                source: source,
                chunking: chunkConfig.method,
                chunk_params: chunkConfig
            }));
            document.getElementById('textInput').value = '';
        }
        
        function scanPDFs() {
            const path = document.getElementById('pdfPath').value.trim();
            if (!path) { alert('Enter a folder path'); return; }
            
            const chunkConfig = getChunkingConfig('pdf');
            
            ws.send(JSON.stringify({
                type: 'scan_pdfs',
                path: path,
                recursive: document.getElementById('pdfRecursive').checked,
                chunking: chunkConfig.method,
                chunk_params: chunkConfig
            }));
            addLog(`Scanning PDFs: ${path}`, 'info');
        }
        
        function handlePDFFiles(files) {
            if (!files || files.length === 0) return;
            addLog(`Uploading ${files.length} PDF files...`, 'info');
            
            for (const file of files) {
                if (file.type === 'application/pdf' || file.name.endsWith('.pdf')) {
                    uploadPDF(file);
                }
            }
            
            // Reset the file input so the same file can be re-selected
            document.getElementById('pdfFileInput').value = '';
        }
        
        function handlePDFFolder(files) {
            if (!files || files.length === 0) return;
            const pdfFiles = Array.from(files).filter(f => 
                f.type === 'application/pdf' || f.name.endsWith('.pdf')
            );
            addLog(`Found ${pdfFiles.length} PDFs in folder`, 'info');
            
            for (const file of pdfFiles) {
                uploadPDF(file);
            }
            
            // Reset the folder input so the same folder can be re-selected
            document.getElementById('pdfFolderInput').value = '';
        }
        
        async function uploadPDF(file) {
            const chunkConfig = getChunkingConfig('pdf');
            const formData = new FormData();
            formData.append('file', file);
            formData.append('chunking', JSON.stringify(chunkConfig));
            
            try {
                const resp = await fetch('/upload/pdf', { 
                    method: 'POST', 
                    body: formData,
                    headers: { 'X-Session-Id': sessionId }
                });
                const data = await resp.json();
                if (data.error) {
                    addLog(`Error uploading ${file.name}: ${data.error}`, 'error');
                } else {
                    addLog(`Uploaded ${file.name}: ${data.chunks} chunks`, 'success');
                }
            } catch (e) {
                addLog(`Upload failed: ${e.message}`, 'error');
            }
        }
        
        function handleImageFiles(files) {
            if (!files || files.length === 0) return;
            addLog(`Uploading ${files.length} image files...`, 'info');
            
            const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
            uploadImages(imageFiles);
            
            // Reset the file input so the same files can be re-selected
            document.getElementById('imageFileInput').value = '';
        }
        
        function handleImageFolder(files) {
            if (!files || files.length === 0) return;
            const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
            const maxFiles = parseInt(document.getElementById('maxImages').value);
            const limited = imageFiles.slice(0, maxFiles);
            
            addLog(`Found ${imageFiles.length} images in folder (using ${limited.length})`, 'info');
            uploadImages(limited);
            
            // Reset the folder input so the same folder can be re-selected
            document.getElementById('imageFolderInput').value = '';
        }
        
        async function uploadImages(files) {
            const describeCheckbox = document.getElementById('describeImages');
            const describe = describeCheckbox ? describeCheckbox.checked : false;
            const describeMethod = document.getElementById('imageDescribeMethod')?.value || 'semantic';
            console.log('[uploadImages] describe:', describe, 'method:', describeMethod);
            addLog(`Uploading ${files.length} images (Describe: ${describe ? describeMethod : 'OFF'})`, 'info');
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const formData = new FormData();
                formData.append('file', file);
                formData.append('describe', describe ? 'true' : 'false');
                formData.append('describe_method', describeMethod);
                
                try {
                    const resp = await fetch('/upload/image', { 
                        method: 'POST', 
                        body: formData,
                        headers: { 'X-Session-Id': sessionId }
                    });
                    const data = await resp.json();
                    if (i % 10 === 0 || i === files.length - 1) {
                        addLog(`Uploaded ${i + 1}/${files.length} images`, 'info');
                    }
                } catch (e) {
                    addLog(`Image upload failed: ${e.message}`, 'error');
                }
            }
            addLog(`Finished uploading ${files.length} images`, 'success');
        }
        
        function scanImages() {
            const path = document.getElementById('imagePath').value.trim();
            if (!path) { alert('Enter a folder path'); return; }
            
            ws.send(JSON.stringify({
                type: 'scan_images',
                path: path,
                recursive: document.getElementById('imageRecursive').checked,
                max_files: parseInt(document.getElementById('maxImages').value),
                describe: document.getElementById('describeImages').checked
            }));
            addLog(`Scanning images: ${path}`, 'info');
        }
        
        function clearCorpus() {
            if (confirm('Clear all data?')) {
                ws.send(JSON.stringify({ type: 'clear_corpus' }));
            }
        }
        
        function removeItem(type, index) {
            ws.send(JSON.stringify({ type: 'remove_item', item_type: type, index: index }));
            if (type === 'pdf') corpusData.pdfs.splice(index, 1);
            else if (type === 'image') corpusData.images.splice(index, 1);
            else if (type === 'text') corpusData.texts.splice(index, 1);
            updateDisplay();
        }
        
        function toggleFilters() {
            const mode = document.getElementById('miningMode').value;
            const filtersGroup = document.getElementById('filtersGroup');
            filtersGroup.style.display = mode === 'directional' ? 'block' : 'none';
        }
        
        function startMining() {
            const mode = document.getElementById('miningMode').value;
            const filters = mode === 'directional' ? 
                document.getElementById('filters').value.split(',').map(f => f.trim()).filter(f => f) : 
                [];
            
            // Get header controls
            const outputLanguage = document.getElementById('outputLanguage').value;
            const llmTemperature = parseFloat(document.getElementById('llmTemperature').value) || 0.7;
                
            ws.send(JSON.stringify({
                type: 'start_mining',
                config: {
                    mode: mode,
                    filters: filters,
                    embedder: document.getElementById('embedder').value,
                    k_neighbors: parseInt(document.getElementById('kNeighbors').value),
                    min_cluster_size: parseInt(document.getElementById('minCluster').value),
                    resolution: parseFloat(document.getElementById('resolution').value),
                    use_llm: document.getElementById('useLLM').checked,
                    llm_model: document.getElementById('llmModel').value,
                    semantic_spread: parseFloat(document.querySelector('input[name="semanticSpread"]:checked').value),
                    output_language: outputLanguage,
                    temperature: llmTemperature
                }
            }));
        }
        
        function displayResults(result) {
            console.log('=== DISPLAY RESULTS CALLED ===');
            console.log('[displayResults] result keys:', Object.keys(result || {}));
            console.log('[displayResults] result.metrics keys:', result?.metrics ? Object.keys(result.metrics) : 'NONE');
            console.log('[displayResults] embedding_coords length:', result?.metrics?.embedding_coords?.length || 'NONE');
            
            const container = document.getElementById('archetypesGrid');
            const archetypes = result.archetypes;
            
            if (!archetypes || Object.keys(archetypes).length === 0) {
                container.innerHTML = '<div class="empty-state"><p>No archetypes found</p></div>';
                return;
            }
            
            document.getElementById('archetypeCount').textContent = `${Object.keys(archetypes).length} archetypes`;
            document.getElementById('exportGroup').style.display = 'flex';
            
            container.innerHTML = Object.entries(archetypes).map(([name, desc], idx) => {
                const descriptors = Array.isArray(desc) ? desc : [];
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                return `
                    <div class="archetype-card" style="border-left-color: ${color}">
                        <div class="archetype-header">
                            <div class="archetype-name" style="color: ${color}">${name}</div>
                            <span class="archetype-count" style="background: ${color}">${descriptors.length}</span>
                        </div>
                        <div class="descriptor-tags">
                            ${descriptors.slice(0, 12).map(d => 
                                `<span class="descriptor-tag">${d}</span>`).join('')}
                            ${descriptors.length > 12 ? 
                                `<span class="descriptor-tag more">+${descriptors.length - 12} more</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Store cluster data for visualization
            clusterData = result;
            updateClusterViz(result);
            
            // Display metrics if available
            console.log('[UI] Result metrics:', result.metrics ? 'present' : 'missing');
            if (result.metrics) {
                console.log('[UI] Calling displayMetrics with', Object.keys(result.archetypes || {}).length, 'archetypes');
                console.log('[UI] Embedding coords:', result.metrics.embedding_coords?.length || 0);
                displayMetrics(result.metrics, Object.keys(archetypes));
            }
        }
        
        // ============================================================
        // CREATIVE METRICS VISUALIZATION
        // Constellation, Similarity Matrix, and Quality Metrics
        // ============================================================
        
        let metricsData = null;
        
        function displayMetrics(metrics, archetypeNames) {
            console.log('[displayMetrics] Called with', archetypeNames?.length, 'archetypes');
            console.log('[displayMetrics] metrics.embedding_coords:', metrics.embedding_coords?.length);
            
            metricsData = { metrics, archetypeNames };
            const corpus = metrics.corpus || {};
            const perArch = metrics.per_archetype || {};
            
            // Update Quality Hero Score
            const quality = corpus.quality || 0;
            document.getElementById('qualityScore').textContent = (quality * 100).toFixed(0);
            
            // Animate the quality ring
            const ringFill = document.getElementById('qualityRingFill');
            const circumference = 175.9; // 2 * PI * 28
            const offset = circumference * (1 - Math.min(quality, 1));
            ringFill.style.strokeDashoffset = offset;
            
            // Update quality stats
            document.getElementById('metricCoherence').textContent = ((corpus.coherence || 0) * 100).toFixed(0) + '%';
            document.getElementById('metricSeparation').textContent = ((corpus.separation || 0) * 100).toFixed(0) + '%';
            document.getElementById('metricFocus').textContent = ((corpus.focus || 0) * 100).toFixed(0) + '%';
            document.getElementById('metricBalance').textContent = ((corpus.balance || 0) * 100).toFixed(0) + '%';
            
            // Draw 3D embedding visualization
            setTimeout(() => draw3DEmbeddings(metrics.embedding_coords || [], archetypeNames), 50);
            
            // Draw similarity matrix
            if (metrics.inter_similarity) {
                drawSimilarityMatrix(metrics.inter_similarity, archetypeNames);
            }
            
            // Render per-archetype metric cards
            renderArchetypeCards(perArch, archetypeNames);
        }
        
        function renderArchetypeCards(perArch, archetypeNames) {
            const container = document.getElementById('archetypeMetricsGrid');
            
            container.innerHTML = archetypeNames.map((name, idx) => {
                const m = perArch[name] || { dispersion: 0, leakage: 0, entropy: 0, size: 0 };
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                const shortName = name.length > 14 ? name.slice(0, 14) + '' : name;
                
                return `
                    <div class="archetype-metric-card" style="border-left-color: ${color}">
                        <div class="archetype-metric-header">
                            <div class="archetype-metric-name" title="${name}">${shortName}</div>
                            <div class="archetype-metric-size">${m.size} items</div>
                        </div>
                        <div class="metric-bars">
                            <div class="metric-bar-row">
                                <span class="metric-bar-label">D</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill dispersion" style="width: ${Math.min(m.dispersion * 100, 100)}%"></div>
                                </div>
                                <span class="metric-bar-value">${(m.dispersion * 100).toFixed(0)}%</span>
                            </div>
                            <div class="metric-bar-row">
                                <span class="metric-bar-label">L</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill leakage" style="width: ${Math.min(m.leakage * 100, 100)}%"></div>
                                </div>
                                <span class="metric-bar-value">${(m.leakage * 100).toFixed(0)}%</span>
                            </div>
                            <div class="metric-bar-row">
                                <span class="metric-bar-label">E</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill entropy" style="width: ${Math.min(m.entropy * 100, 100)}%"></div>
                                </div>
                                <span class="metric-bar-value">${(m.entropy * 100).toFixed(0)}%</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Three.js 3D embedding visualization
        let scene3D, camera3D, renderer3D, controls3D, particles3D;
        let embedding3DInitialized = false;
        
        function draw3DEmbeddings(embeddings, archetypeNames) {
            console.log('[3D] draw3DEmbeddings called with', embeddings?.length, 'embeddings');
            
            const container = document.getElementById('embedding3DContainer');
            if (!container) {
                console.warn('[3D] Container not found');
                return;
            }
            if (!embeddings || embeddings.length === 0) {
                console.warn('[3D] No embeddings data');
                return;
            }
            
            // Clean up previous scene
            if (renderer3D) {
                try {
                    container.removeChild(renderer3D.domElement);
                    renderer3D.dispose();
                } catch(e) { console.warn('[3D] Cleanup error:', e); }
            }
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            console.log('[3D] Container dimensions:', width, 'x', height);
            
            if (width < 50 || height < 50) {
                console.warn('[3D] Container too small, skipping render');
                return;
            }
            
            try {
            // Initialize scene
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0x0a0a0f);
            
            // Camera
            camera3D = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera3D.position.set(2, 1.5, 2.5);
            
            // Renderer
            renderer3D = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer3D.setSize(width, height);
            renderer3D.setPixelRatio(window.devicePixelRatio);
            container.insertBefore(renderer3D.domElement, container.firstChild);
            
            // Controls
            controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
            controls3D.enableDamping = true;
            controls3D.dampingFactor = 0.05;
            controls3D.autoRotate = true;
            controls3D.autoRotateSpeed = 0.5;
            
            // Build color map
            const colorMap = {};
            archetypeNames.forEach((name, idx) => {
                const hex = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                colorMap[name] = new THREE.Color(hex);
            });
            
            // Create point cloud geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(embeddings.length * 3);
            const colors = new Float32Array(embeddings.length * 3);
            
            embeddings.forEach((e, i) => {
                positions[i * 3] = e.x;
                positions[i * 3 + 1] = e.y;
                positions[i * 3 + 2] = e.z;
                
                const color = colorMap[e.archetype] || new THREE.Color(0x888888);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            });
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Simple point material (no shaders to avoid CSP issues)
            const pointsMaterial = new THREE.PointsMaterial({
                size: 0.12,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });
            
            particles3D = new THREE.Points(geometry, pointsMaterial);
            scene3D.add(particles3D);
            
            // Add centroid spheres for each archetype
            const centroidsByArch = {};
            embeddings.forEach(e => {
                if (!centroidsByArch[e.archetype]) {
                    centroidsByArch[e.archetype] = { x: 0, y: 0, z: 0, count: 0 };
                }
                centroidsByArch[e.archetype].x += e.x;
                centroidsByArch[e.archetype].y += e.y;
                centroidsByArch[e.archetype].z += e.z;
                centroidsByArch[e.archetype].count++;
            });
            
            Object.entries(centroidsByArch).forEach(([arch, c]) => {
                const cx = c.x / c.count;
                const cy = c.y / c.count;
                const cz = c.z / c.count;
                
                // Centroid sphere
                const sphereGeo = new THREE.SphereGeometry(0.06, 16, 16);
                const color = colorMap[arch] || new THREE.Color(0x888888);
                const sphereMat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                sphere.position.set(cx, cy, cz);
                scene3D.add(sphere);
                
                // Wireframe hull hint
                const wireGeo = new THREE.SphereGeometry(0.25, 8, 6);
                const wireMat = new THREE.MeshBasicMaterial({
                    color: color,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.15
                });
                const wire = new THREE.Mesh(wireGeo, wireMat);
                wire.position.set(cx, cy, cz);
                scene3D.add(wire);
            });
            
            // Add subtle grid
            const gridHelper = new THREE.GridHelper(2, 10, 0x333333, 0x222222);
            gridHelper.position.y = -1;
            scene3D.add(gridHelper);
            
            // Update legend
            const legendEl = document.getElementById('embedding3DLegend');
            legendEl.innerHTML = archetypeNames.map((name, idx) => {
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                const count = embeddings.filter(e => e.archetype === name).length;
                return `<span style="color:${color}"></span> ${name.slice(0, 10)}${name.length > 10 ? '' : ''} (${count})`;
            }).join(' &nbsp; ');
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls3D.update();
                renderer3D.render(scene3D, camera3D);
            }
            animate();
            
            embedding3DInitialized = true;
            console.log('[3D] Visualization initialized successfully');
            
            } catch(err) {
                console.error('[3D] Error creating visualization:', err);
            }
        }
        
        function drawSimilarityMatrix(interSimilarity, archetypeNames) {
            const canvas = document.getElementById('similarityMatrix');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const wrapper = canvas.parentElement;
            // Make it square, fitting within the container
            const size = Math.min(wrapper.clientWidth, wrapper.clientHeight, 160);
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.scale(dpr, dpr);
            
            const n = archetypeNames.length;
            if (n === 0) return;
            
            const cellSize = size / n;
            
            // Draw cells
            archetypeNames.forEach((name_i, i) => {
                archetypeNames.forEach((name_j, j) => {
                    const sim = interSimilarity[name_i]?.[name_j] || 0;
                    const x = j * cellSize;
                    const y = i * cellSize;
                    
                    // Color gradient from dark purple (low) to bright purple (high)
                    const intensity = Math.pow(sim, 0.7);  // Gamma correction for visibility
                    
                    if (i === j) {
                        // Diagonal: always full
                        ctx.fillStyle = hexToRgba(CLUSTER_COLORS[i % CLUSTER_COLORS.length], 0.8);
                    } else {
                        // Off-diagonal: gradient based on similarity
                        const r = Math.round(139 + (194 - 139) * intensity);
                        const g = Math.round(92 + (166 - 92) * intensity);
                        const b = Math.round(246 + (254 - 246) * intensity);
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.2 + intensity * 0.6})`;
                    }
                    
                    ctx.fillRect(x + 0.5, y + 0.5, cellSize - 1, cellSize - 1);
                    
                    // Add similarity value for larger matrices
                    if (n <= 8 && i !== j && cellSize > 18) {
                        ctx.fillStyle = intensity > 0.5 ? '#fff' : 'rgba(255,255,255,0.5)';
                        ctx.font = `${Math.max(8, cellSize * 0.35)}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText((sim * 100).toFixed(0), x + cellSize / 2, y + cellSize / 2);
                    }
                });
            });
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= n; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(size, i * cellSize);
                ctx.stroke();
            }
        }
        
        // ================================================
        // TOPOLOGY VISUALIZATIONS
        // ================================================
        
        let topologyData = null;
        
        function computeTopologyData(metrics, archetypeNames) {
            if (!metrics || !metrics.embedding_coords || metrics.embedding_coords.length === 0) {
                return null;
            }
            
            const embeddings = metrics.embedding_coords;
            const perArchetype = metrics.per_archetype || {};
            const interSim = metrics.inter_similarity || {};
            
            // Compute centroids for each archetype
            const centroids = {};
            archetypeNames.forEach(name => {
                const pts = embeddings.filter(e => e.archetype === name);
                if (pts.length > 0) {
                    centroids[name] = {
                        x: pts.reduce((s, p) => s + p.x, 0) / pts.length,
                        y: pts.reduce((s, p) => s + p.y, 0) / pts.length,
                        z: pts.reduce((s, p) => s + p.z, 0) / pts.length,
                        mass: pts.length,
                        descriptors: pts
                    };
                }
            });
            
            // Find semantic bridges (descriptors with high similarity to multiple archetypes)
            const bridges = [];
            embeddings.forEach(emb => {
                // Calculate distance to each centroid
                const distances = {};
                let minDist = Infinity;
                let secondMinDist = Infinity;
                let closest = null;
                let secondClosest = null;
                
                Object.entries(centroids).forEach(([name, c]) => {
                    const dist = Math.sqrt(
                        Math.pow(emb.x - c.x, 2) + 
                        Math.pow(emb.y - c.y, 2) + 
                        Math.pow(emb.z - c.z, 2)
                    );
                    distances[name] = dist;
                    
                    if (dist < minDist) {
                        secondMinDist = minDist;
                        secondClosest = closest;
                        minDist = dist;
                        closest = name;
                    } else if (dist < secondMinDist) {
                        secondMinDist = dist;
                        secondClosest = name;
                    }
                });
                
                // Bridge = close to two different archetypes
                if (closest && secondClosest && closest !== secondClosest) {
                    const ratio = secondMinDist / (minDist + 0.001);
                    if (ratio < 1.5) { // Within 50% distance of closest
                        bridges.push({
                            descriptor: emb.descriptor,
                            archetypes: [closest, secondClosest],
                            strength: 1 / ratio,
                            distances: distances
                        });
                    }
                }
            });
            
            // Sort bridges by strength
            bridges.sort((a, b) => b.strength - a.strength);
            
            // Compute geodesic distances (using centroid distances as proxy)
            const geodesicMatrix = {};
            let minGeo = Infinity, maxGeo = 0;
            let closestPair = '', farthestPair = '';
            
            archetypeNames.forEach(name_i => {
                geodesicMatrix[name_i] = {};
                archetypeNames.forEach(name_j => {
                    if (name_i === name_j) {
                        geodesicMatrix[name_i][name_j] = 0;
                    } else if (centroids[name_i] && centroids[name_j]) {
                        const dist = Math.sqrt(
                            Math.pow(centroids[name_i].x - centroids[name_j].x, 2) +
                            Math.pow(centroids[name_i].y - centroids[name_j].y, 2) +
                            Math.pow(centroids[name_i].z - centroids[name_j].z, 2)
                        );
                        geodesicMatrix[name_i][name_j] = dist;
                        
                        if (dist > 0 && dist < minGeo) {
                            minGeo = dist;
                            closestPair = `${name_i.slice(0,8)}-${name_j.slice(0,8)}`;
                        }
                        if (dist > maxGeo) {
                            maxGeo = dist;
                            farthestPair = `${name_i.slice(0,8)}-${name_j.slice(0,8)}`;
                        }
                    }
                });
            });
            
            // Compute average geodesic
            let sumGeo = 0, countGeo = 0;
            archetypeNames.forEach(name_i => {
                archetypeNames.forEach(name_j => {
                    if (name_i !== name_j && geodesicMatrix[name_i]?.[name_j]) {
                        sumGeo += geodesicMatrix[name_i][name_j];
                        countGeo++;
                    }
                });
            });
            const avgGeodesic = countGeo > 0 ? sumGeo / countGeo : 0;
            
            // Compute curvature (variance of distances from centroid within each archetype)
            let totalCurvature = 0;
            archetypeNames.forEach(name => {
                const pts = embeddings.filter(e => e.archetype === name);
                if (pts.length > 1 && centroids[name]) {
                    const c = centroids[name];
                    const dists = pts.map(p => Math.sqrt(
                        Math.pow(p.x - c.x, 2) + Math.pow(p.y - c.y, 2) + Math.pow(p.z - c.z, 2)
                    ));
                    const mean = dists.reduce((s, d) => s + d, 0) / dists.length;
                    const variance = dists.reduce((s, d) => s + Math.pow(d - mean, 2), 0) / dists.length;
                    totalCurvature += Math.sqrt(variance);
                }
            });
            const meanCurvature = archetypeNames.length > 0 ? totalCurvature / archetypeNames.length : 0;
            
            // Connectivity = average inter-archetype similarity
            let sumSim = 0, countSim = 0;
            archetypeNames.forEach(name_i => {
                archetypeNames.forEach(name_j => {
                    if (name_i !== name_j && interSim[name_i]?.[name_j]) {
                        sumSim += interSim[name_i][name_j];
                        countSim++;
                    }
                });
            });
            const connectivity = countSim > 0 ? sumSim / countSim : 0;
            
            return {
                centroids,
                bridges: bridges.slice(0, 10), // Top 10
                geodesicMatrix,
                minGeodesic: minGeo === Infinity ? 0 : minGeo,
                maxGeodesic: maxGeo,
                avgGeodesic,
                closestPair,
                farthestPair,
                meanCurvature,
                connectivity,
                totalMass: embeddings.length
            };
        }
        
        function drawTopologyVisualizations(metrics, archetypeNames) {
            topologyData = computeTopologyData(metrics, archetypeNames);
            if (!topologyData) return;
            
            // Update topology metrics
            document.getElementById('topoTotalMass').textContent = topologyData.totalMass;
            document.getElementById('topoMeanCurvature').textContent = topologyData.meanCurvature.toFixed(3);
            document.getElementById('topoConnectivity').textContent = (topologyData.connectivity * 100).toFixed(1) + '%';
            document.getElementById('topoNumBridges').textContent = topologyData.bridges.length;
            document.getElementById('topoAvgGeodesic').textContent = topologyData.avgGeodesic.toFixed(3);
            document.getElementById('topoDiameter').textContent = topologyData.maxGeodesic.toFixed(3);
            
            // Update geodesic stats
            document.getElementById('geoMinDist').textContent = topologyData.minGeodesic.toFixed(3);
            document.getElementById('geoMaxDist').textContent = topologyData.maxGeodesic.toFixed(3);
            document.getElementById('geoClosestPair').textContent = topologyData.closestPair || '';
            document.getElementById('geoFarthestPair').textContent = topologyData.farthestPair || '';
            document.getElementById('geoMeanDist').textContent = topologyData.avgGeodesic.toFixed(3);
            
            // Draw gravity field
            drawGravityField(metrics.embedding_coords, archetypeNames, topologyData.centroids);
            
            // Draw gradient flow (pass embeddings for richer visualization)
            drawGradientFlow(archetypeNames, topologyData.centroids, metrics.embedding_coords);
            
            // Draw bridges list
            drawBridgesList(topologyData.bridges);
            
            // Draw geodesic matrix
            drawGeodesicMatrix(topologyData.geodesicMatrix, archetypeNames);
        }
        
        function drawGravityField(embeddings, archetypeNames, centroids) {
            const canvas = document.getElementById('gravityCanvas');
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            ctx.scale(dpr, dpr);
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Clear
            ctx.fillStyle = 'rgba(10, 5, 20, 1)';
            ctx.fillRect(0, 0, width, height);
            
            // Map 3D coordinates to 2D (simple projection)
            const mapCoord = (x, y) => ({
                x: width * 0.5 + x * width * 0.35,
                y: height * 0.5 - y * height * 0.35
            });
            
            // Draw gravity wells (radial gradients for each archetype)
            Object.entries(centroids).forEach(([name, c], idx) => {
                const pos = mapCoord(c.x, c.y);
                const radius = Math.sqrt(c.mass) * 25 + 40;
                
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, radius);
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                gradient.addColorStop(0, color + '40');
                gradient.addColorStop(0.5, color + '15');
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw gravitational field lines (concentric circles)
            Object.entries(centroids).forEach(([name, c], idx) => {
                const pos = mapCoord(c.x, c.y);
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                
                for (let r = 15; r < 80; r += 20) {
                    ctx.strokeStyle = color + '20';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // Draw descriptor particles
            embeddings.forEach((emb, i) => {
                const pos = mapCoord(emb.x, emb.y);
                const archIdx = archetypeNames.indexOf(emb.archetype);
                const color = archIdx >= 0 ? CLUSTER_COLORS[archIdx % CLUSTER_COLORS.length] : '#5eead4';
                
                ctx.fillStyle = color + 'aa';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 2.5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw archetype centroids
            Object.entries(centroids).forEach(([name, c], idx) => {
                const pos = mapCoord(c.x, c.y);
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                
                // Outer glow
                ctx.shadowColor = color;
                ctx.shadowBlur = 15;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Inner bright
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Label - full name with background for readability
                const label = name;
                ctx.font = '10px sans-serif';
                const textWidth = ctx.measureText(label).width;
                
                // Draw background pill
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.roundRect(pos.x - textWidth/2 - 4, pos.y - 22, textWidth + 8, 14, 3);
                ctx.fill();
                
                // Draw text
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText(label, pos.x, pos.y - 12);
            });
        }
        
        function drawGradientFlow(archetypeNames, centroids, embeddings) {
            const canvas = document.getElementById('gradientCanvas');
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            ctx.scale(dpr, dpr);
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Clear with dark gradient
            const bgGrad = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
            bgGrad.addColorStop(0, 'rgba(15, 10, 30, 1)');
            bgGrad.addColorStop(1, 'rgba(5, 5, 10, 1)');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);
            
            const mapCoord = (x, y) => ({
                x: width * 0.5 + x * width * 0.4,
                y: height * 0.5 - y * height * 0.4
            });
            
            const centroidList = Object.entries(centroids);
            if (centroidList.length === 0) return;
            
            // STEP 1: Draw Voronoi-like regions (colored zones)
            const resolution = 4; // Pixel resolution for region fill
            for (let px = 0; px < width; px += resolution) {
                for (let py = 0; py < height; py += resolution) {
                    const nx = (px - width * 0.5) / (width * 0.4);
                    const ny = -(py - height * 0.5) / (height * 0.4);
                    
                    // Find closest and second closest archetype
                    let minDist = Infinity, secondDist = Infinity;
                    let closestIdx = 0;
                    
                    centroidList.forEach(([name, c], idx) => {
                        const dist = Math.sqrt(Math.pow(c.x - nx, 2) + Math.pow(c.y - ny, 2));
                        if (dist < minDist) {
                            secondDist = minDist;
                            minDist = dist;
                            closestIdx = idx;
                        } else if (dist < secondDist) {
                            secondDist = dist;
                        }
                    });
                    
                    // Blend factor: 1 = pure region, 0 = boundary
                    const blend = Math.min(1, (secondDist - minDist) * 3);
                    const color = CLUSTER_COLORS[closestIdx % CLUSTER_COLORS.length];
                    
                    // Softer gradient with distance
                    const distFade = Math.max(0, 1 - minDist * 0.8);
                    const alpha = blend * distFade * 0.25;
                    
                    ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.fillRect(px, py, resolution, resolution);
                }
            }
            
            // STEP 2: Draw boundary lines between regions (saddle ridges)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            
            for (let px = 0; px < width; px += 8) {
                for (let py = 0; py < height; py += 8) {
                    const nx = (px - width * 0.5) / (width * 0.4);
                    const ny = -(py - height * 0.5) / (height * 0.4);
                    
                    let minDist = Infinity, secondDist = Infinity;
                    centroidList.forEach(([name, c], idx) => {
                        const dist = Math.sqrt(Math.pow(c.x - nx, 2) + Math.pow(c.y - ny, 2));
                        if (dist < minDist) {
                            secondDist = minDist;
                            minDist = dist;
                        } else if (dist < secondDist) {
                            secondDist = dist;
                        }
                    });
                    
                    // On boundary: distances are similar
                    const ratio = secondDist / (minDist + 0.001);
                    if (ratio < 1.15) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // STEP 3: Draw flow streamlines from edges toward centroids
            const numStreamlines = 24;
            for (let i = 0; i < numStreamlines; i++) {
                // Start from edge of canvas
                const angle = (i / numStreamlines) * Math.PI * 2;
                const radius = Math.min(width, height) * 0.45;
                let x = width/2 + Math.cos(angle) * radius;
                let y = height/2 + Math.sin(angle) * radius;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                // Flow toward nearest centroid
                let prevColor = null;
                for (let step = 0; step < 60; step++) {
                    const nx = (x - width * 0.5) / (width * 0.4);
                    const ny = -(y - height * 0.5) / (height * 0.4);
                    
                    // Compute gradient
                    let gradX = 0, gradY = 0;
                    let totalWeight = 0;
                    let closestIdx = 0;
                    let minDist = Infinity;
                    
                    centroidList.forEach(([name, c], idx) => {
                        const dx = c.x - nx;
                        const dy = c.y - ny;
                        const dist = Math.sqrt(dx * dx + dy * dy) + 0.05;
                        const weight = c.mass / (dist * dist);
                        
                        gradX += (dx / dist) * weight;
                        gradY += (dy / dist) * weight;
                        totalWeight += weight;
                        
                        if (dist < minDist) {
                            minDist = dist;
                            closestIdx = idx;
                        }
                    });
                    
                    if (totalWeight > 0) {
                        gradX /= totalWeight;
                        gradY /= totalWeight;
                    }
                    
                    const mag = Math.sqrt(gradX * gradX + gradY * gradY);
                    if (mag < 0.01 || minDist < 0.1) break;
                    
                    // Step in gradient direction
                    const stepSize = 6;
                    x += (gradX / mag) * stepSize;
                    y -= (gradY / mag) * stepSize;
                    
                    const color = CLUSTER_COLORS[closestIdx % CLUSTER_COLORS.length];
                    const alpha = Math.max(0.1, 0.5 - step * 0.008);
                    
                    if (prevColor !== color) {
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    }
                    
                    ctx.strokeStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.lineWidth = 1.5;
                    ctx.lineTo(x, y);
                    prevColor = color;
                }
                ctx.stroke();
            }
            
            // STEP 4: Draw archetype nodes with labels
            centroidList.forEach(([name, c], idx) => {
                const pos = mapCoord(c.x, c.y);
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                const radius = Math.sqrt(c.mass) * 2 + 8;
                
                // Glow
                const glow = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, radius * 2);
                glow.addColorStop(0, color + 'aa');
                glow.addColorStop(0.5, color + '44');
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Label with background for readability
                const label = name;
                ctx.font = 'bold 10px sans-serif';
                const textWidth = ctx.measureText(label).width;
                
                // Draw background pill
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.roundRect(pos.x - textWidth/2 - 4, pos.y + radius + 6, textWidth + 8, 14, 3);
                ctx.fill();
                
                // Draw text
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(label, pos.x, pos.y + radius + 16);
                
                // Mass indicator
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '8px sans-serif';
                ctx.fillText(`n=${c.mass}`, pos.x, pos.y + radius + 28);
            });
        }
        
        function drawBridgesList(bridges) {
            const container = document.getElementById('bridgesList');
            if (!container) return;
            
            if (bridges.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding: 1rem; min-height: auto;">
                        <p style="color: var(--text-muted); font-size: 0.7rem;">No semantic bridges found</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = bridges.map(bridge => `
                <div class="bridge-item">
                    <div class="bridge-descriptor">${bridge.descriptor.slice(0, 40)}${bridge.descriptor.length > 40 ? '' : ''}</div>
                    <div class="bridge-archetypes">
                        <span class="bridge-archetype-tag">${bridge.archetypes[0].slice(0, 10)}</span>
                        <span style="color: var(--text-muted);"></span>
                        <span class="bridge-archetype-tag">${bridge.archetypes[1].slice(0, 10)}</span>
                    </div>
                    <div class="bridge-strength">${(bridge.strength * 100).toFixed(0)}%</div>
                </div>
            `).join('');
        }
        
        function drawGeodesicMatrix(geodesicMatrix, archetypeNames) {
            const canvas = document.getElementById('geodesicCanvas');
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            // Make it square and larger
            const availableWidth = container.clientWidth - 20;
            const size = Math.min(availableWidth, 220);
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.scale(dpr, dpr);
            
            const n = archetypeNames.length;
            if (n === 0) return;
            
            // Find min/max for normalization (excluding diagonal)
            let minDist = Infinity, maxDist = 0;
            archetypeNames.forEach(name_i => {
                archetypeNames.forEach(name_j => {
                    if (name_i !== name_j) {
                        const dist = geodesicMatrix[name_i]?.[name_j] || 0;
                        if (dist > 0 && dist < minDist) minDist = dist;
                        if (dist > maxDist) maxDist = dist;
                    }
                });
            });
            if (minDist === Infinity) minDist = 0;
            
            const labelSpace = 35; // Space for labels
            const matrixSize = size - labelSpace;
            const cellSize = matrixSize / n;
            
            // Draw background
            ctx.fillStyle = 'rgba(10, 10, 20, 1)';
            ctx.fillRect(0, 0, size, size);
            
            // Draw matrix cells
            archetypeNames.forEach((name_i, i) => {
                archetypeNames.forEach((name_j, j) => {
                    const dist = geodesicMatrix[name_i]?.[name_j] || 0;
                    const x = labelSpace + j * cellSize;
                    const y = labelSpace + i * cellSize;
                    
                    if (i === j) {
                        // Diagonal - self distance
                        ctx.fillStyle = '#0f0f1a';
                    } else {
                        // Normalize: close = teal, far = purple
                        const range = maxDist - minDist || 1;
                        const norm = (dist - minDist) / range; // 0 = closest, 1 = farthest
                        
                        // Color gradient: teal (close) -> blue -> purple (far)
                        const r = Math.floor(20 + norm * 119);  // 20 -> 139
                        const g = Math.floor(184 - norm * 92);  // 184 -> 92
                        const b = Math.floor(166 + norm * 80);  // 166 -> 246
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    }
                    
                    ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
                    
                    // Show distance value in cells if space allows
                    if (cellSize > 30 && i !== j) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.font = '8px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(dist.toFixed(2), x + cellSize/2, y + cellSize/2);
                    }
                });
            });
            
            // Draw row labels (left side)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            archetypeNames.forEach((name, i) => {
                const y = labelSpace + i * cellSize + cellSize/2;
                const label = name.slice(0, 5);
                ctx.fillStyle = CLUSTER_COLORS[i % CLUSTER_COLORS.length];
                ctx.fillText(label, labelSpace - 4, y);
            });
            
            // Draw column labels (top)
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            archetypeNames.forEach((name, j) => {
                const x = labelSpace + j * cellSize + cellSize/2;
                const label = name.slice(0, 5);
                ctx.fillStyle = CLUSTER_COLORS[j % CLUSTER_COLORS.length];
                ctx.save();
                ctx.translate(x, labelSpace - 4);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(label, 0, 0);
                ctx.restore();
            });
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= n; i++) {
                ctx.beginPath();
                ctx.moveTo(labelSpace + i * cellSize, labelSpace);
                ctx.lineTo(labelSpace + i * cellSize, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(labelSpace, labelSpace + i * cellSize);
                ctx.lineTo(size, labelSpace + i * cellSize);
                ctx.stroke();
            }
        }
        
        // ================================================
        // VISUALS TAB - AI Generated Archetype Art (Gemini)
        // ================================================
        
        let selectedArchetypesForVision = [];
        let geminiApiKey = localStorage.getItem('gemini_api_key') || '';
        let generatedVisions = [];
        
        // Initialize API key from localStorage
        function initVisualsTab() {
            const apiKeyInput = document.getElementById('geminiApiKey');
            if (apiKeyInput && geminiApiKey) {
                apiKeyInput.value = geminiApiKey;
            }
            updateGenerateButton();
        }
        
        function toggleApiKeyVisibility() {
            const input = document.getElementById('geminiApiKey');
            input.type = input.type === 'password' ? 'text' : 'password';
        }
        
        function saveApiKey() {
            const input = document.getElementById('geminiApiKey');
            geminiApiKey = input.value.trim();
            localStorage.setItem('gemini_api_key', geminiApiKey);
            updateGenerateButton();
            
            const status = document.getElementById('generateStatus');
            status.textContent = geminiApiKey ? ' API key saved' : 'API key cleared';
            status.className = 'generate-status ' + (geminiApiKey ? 'success' : '');
            setTimeout(() => { status.textContent = ''; status.className = 'generate-status'; }, 2000);
        }
        
        function updateVisualsArchetypeChips() {
            const chipsContainer = document.getElementById('visualsArchetypeChips');
            if (!chipsContainer || !currentResults) return;
            
            const archetypeNames = Object.keys(currentResults.archetypes || {});
            
            if (archetypeNames.length === 0) {
                chipsContainer.innerHTML = '<div class="empty-chip">Run builder to see archetypes</div>';
                return;
            }
            
            chipsContainer.innerHTML = archetypeNames.map((name, idx) => {
                const isSelected = selectedArchetypesForVision.includes(name);
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                // Escape quotes and apostrophes for safe use in onclick handler
                const escapedName = name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                return `<div class="archetype-chip ${isSelected ? 'selected' : ''}" 
                             style="${isSelected ? '' : `border-color: ${color}40; color: ${color};`}"
                             onclick="toggleArchetypeForVision('${escapedName}')">${name}</div>`;
            }).join('');
            
            updateSelectedCount();
        }
        
        function toggleArchetypeForVision(name) {
            const idx = selectedArchetypesForVision.indexOf(name);
            if (idx >= 0) {
                selectedArchetypesForVision.splice(idx, 1);
            } else {
                selectedArchetypesForVision.push(name);
            }
            updateVisualsArchetypeChips();
            updateGenerateButton();
        }
        
        function clearArchetypeSelection() {
            selectedArchetypesForVision = [];
            updateVisualsArchetypeChips();
            updateGenerateButton();
        }
        
        function updateSelectedCount() {
            const countEl = document.getElementById('selectedArchetypesCount');
            const clearBtn = document.getElementById('clearSelectionBtn');
            if (countEl) countEl.textContent = selectedArchetypesForVision.length;
            if (clearBtn) clearBtn.style.display = selectedArchetypesForVision.length > 0 ? 'inline-block' : 'none';
        }
        
        function updateGenerateButton() {
            const btn = document.getElementById('generateVisionBtn');
            if (!btn) return;
            btn.disabled = !geminiApiKey || selectedArchetypesForVision.length < 2;
        }
        
        function buildVisionPrompt(archetypes, style) {
            if (!currentResults) return '';
            
            // Get descriptors for each archetype
            const archetypeDescriptions = archetypes.map(name => {
                const words = currentResults.archetypes[name] || [];
                return `${name}: ${words.slice(0, 8).join(', ')}`;
            }).join('\n');
            
            // Find semantic bridges between the selected archetypes (if checkbox is checked)
            let bridgeSection = '';
            const enforceBridges = document.getElementById('enforceSemanticBridges')?.checked ?? false;
            if (enforceBridges && topologyData && topologyData.bridges && topologyData.bridges.length > 0) {
                // Filter bridges that connect the selected archetypes
                const relevantBridges = topologyData.bridges.filter(bridge => {
                    const [a1, a2] = bridge.archetypes;
                    return archetypes.includes(a1) && archetypes.includes(a2);
                });
                
                if (relevantBridges.length > 0) {
                    const bridgeDescriptions = relevantBridges.slice(0, 5).map(bridge => {
                        return `"${bridge.descriptor}" bridges ${bridge.archetypes[0]}  ${bridge.archetypes[1]}`;
                    }).join('\n');
                    
                    bridgeSection = `
SEMANTIC BRIDGES (words that connect archetypes - use these to visualize the interaction):
${bridgeDescriptions}

These bridge words represent the conceptual overlap between archetypes. Visualize these connections prominently - they are the semantic representations of the interaction points where the archetypes meet and interact.`;
                }
            }
            
            // Style descriptions inspired by Codex Seraphinianus
            const styleDescriptions = {
                botanical: 'fantastical botanical illustrations with impossible hybrid plants, root systems that form symbolic connections, flowering structures that represent concepts, in the style of ancient herbal manuscripts crossed with alien botany',
                mechanical: 'intricate mechanical diagrams with gears, pistons, and clockwork mechanisms that impossibly transform into organic forms, technical cross-sections revealing inner symbolic workings, brass and copper tones',
                anatomical: 'surreal anatomical illustrations combining human, animal, and imaginary organ structures, medical diagrams of impossible beings, veins and nerves as channels of meaning, on aged parchment',
                cosmological: 'celestial maps and astronomical charts with orbiting symbolic bodies, zodiacal wheel arrangements, cosmic diagrams showing the gravitational relationships between concepts, deep space mysticism',
                elemental: 'diagrams of impossible physics and new elemental forces - gravity bending into spirals, light crystallizing into solid forms, magnetic fields visible as flowing ribbons, thermodynamic processes that reverse entropy, forces that push and pull between the archetypes like a physics textbook from another dimension',
                scalefree: 'fractal zoom illustration showing the archetypes manifesting simultaneously at quantum, cellular, human, planetary, and cosmic scales - atoms that mirror galaxies, cells that contain cities, a continuous visual journey from the infinitesimal to the infinite where patterns repeat across all scales of existence',
                creatures: 'bestiary of fantastical beings and characters that embody each archetype - chimeric creatures with symbolic anatomies, masked figures in ritual poses, mythological hybrids, spirit animals with glowing sigils, humanoid forms merged with abstract concepts, each creature interacting with the others in a symbolic ecosystem'
            };
            
            const styleDesc = styleDescriptions[style] || styleDescriptions.botanical;
            
            return `Create a single highly detailed illustration in the distinctive style of the Codex Seraphinianus - an encyclopedia of an imaginary world with surreal, dreamlike imagery and invented writing systems.

The image should visualize the INTERACTION and RELATIONSHIP between these archetypal concepts:

${archetypeDescriptions}
${bridgeSection}

Style requirements:
- ${styleDesc}
- Include invented glyphs or symbolic writing as decorative elements
- Show how the archetypes connect, merge, or interact with each other visually
- Each archetype should have a distinct but harmonious visual identity
- Use subtle color palette with aged paper texture feel
- Include fine detail work suitable for a mysterious ancient codex
- The archetypes should be interacting, not just placed side by side

The overall composition should feel like a page from an alien encyclopedia documenting the relationship between these abstract concepts as if they were natural phenomena.`;
        }
        
        async function generateArchetypeVision() {
            if (!geminiApiKey || selectedArchetypesForVision.length < 2) return;
            
            const btn = document.getElementById('generateVisionBtn');
            const status = document.getElementById('generateStatus');
            const style = document.querySelector('input[name="visualStyle"]:checked')?.value || 'botanical';
            const model = document.querySelector('input[name="imageModel"]:checked')?.value || 'gemini-2.5-flash-image';
            
            // UI feedback
            btn.disabled = true;
            btn.classList.add('loading');
            status.textContent = `Generating with ${model.split('-')[0]}...`;
            status.className = 'generate-status';
            
            const prompt = buildVisionPrompt(selectedArchetypesForVision, style);
            
            try {
                // Call backend proxy to avoid CORS issues
                const response = await fetch('/api/generate-vision', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-Id': sessionId
                    },
                    body: JSON.stringify({
                        apiKey: geminiApiKey,
                        prompt: prompt,
                        model: model
                    })
                });
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Generation failed');
                }
                
                // Add to gallery
                addVisionToGallery({
                    archetypes: [...selectedArchetypesForVision],
                    style: style,
                    model: model,
                    prompt: prompt,
                    imageData: data.imageData,
                    timestamp: new Date().toISOString()
                });
                
                status.textContent = ' Vision generated!';
                status.className = 'generate-status success';
                
            } catch (error) {
                console.error('Vision generation error:', error);
                status.textContent = `Error: ${error.message}`;
                status.className = 'generate-status error';
            } finally {
                btn.disabled = false;
                btn.classList.remove('loading');
                updateGenerateButton();
            }
        }
        
        function addVisionToGallery(vision) {
            generatedVisions.unshift(vision);
            renderVisualsGallery();
        }
        
        function renderVisualsGallery() {
            const gallery = document.getElementById('visualsGallery');
            if (!gallery) return;
            
            if (generatedVisions.length === 0) {
                gallery.innerHTML = `
                    <div class="visuals-placeholder">
                        <div class="visuals-placeholder-icon"></div>
                        <p>Select archetypes and generate to see their visual manifestation</p>
                    </div>
                `;
                // Hide gallery actions when empty
                const actionsEl = document.getElementById('galleryActions');
                if (actionsEl) actionsEl.style.display = 'none';
                return;
            }
            
            // Show gallery actions when there are visions
            const actionsEl = document.getElementById('galleryActions');
            if (actionsEl) actionsEl.style.display = 'flex';
            
            gallery.innerHTML = generatedVisions.map((vision, idx) => `
                <div class="vision-card">
                    <div class="vision-card-header">
                        <div class="vision-archetypes">
                            ${vision.archetypes.map(a => `<span class="vision-archetype-tag">${a}</span>`).join('')}
                        </div>
                        <div class="vision-meta">
                            <span class="vision-style-tag">${vision.style}</span>
                            <span class="vision-model-tag">${vision.model?.split('-').slice(0,2).join(' ') || 'gemini'}</span>
                        </div>
                    </div>
                    <div class="vision-image-container">
                        <img class="vision-image" src="${vision.imageData}" alt="Archetype vision" />
                    </div>
                    <div class="vision-actions">
                        <button class="vision-action-btn save-btn" onclick="downloadVision(${idx})"> Save Image</button>
                        <button class="vision-action-btn" onclick="toggleVisionPrompt(${idx})"> Prompt</button>
                        <button class="vision-action-btn" onclick="removeVision(${idx})"> Remove</button>
                    </div>
                    <div class="vision-prompt" id="visionPrompt${idx}" style="display: none;">
                        ${vision.prompt.replace(/\n/g, '<br>')}
                    </div>
                </div>
            `).join('');
        }
        
        function downloadVision(idx) {
            const vision = generatedVisions[idx];
            if (!vision) return;
            
            const link = document.createElement('a');
            link.href = vision.imageData;
            link.download = `egregore_${vision.archetypes.join('_')}_${vision.style}.png`;
            link.click();
        }
        
        function toggleVisionPrompt(idx) {
            const promptEl = document.getElementById(`visionPrompt${idx}`);
            if (promptEl) {
                promptEl.style.display = promptEl.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function removeVision(idx) {
            generatedVisions.splice(idx, 1);
            renderVisualsGallery();
        }
        
        async function downloadAllVisions() {
            if (generatedVisions.length === 0) return;
            
            // Download each vision with a small delay to avoid browser blocking
            for (let i = 0; i < generatedVisions.length; i++) {
                const vision = generatedVisions[i];
                const link = document.createElement('a');
                link.href = vision.imageData;
                link.download = `egregore_${i + 1}_${vision.archetypes.join('_')}_${vision.style}.png`;
                link.click();
                
                // Small delay between downloads
                if (i < generatedVisions.length - 1) {
                    await new Promise(r => setTimeout(r, 300));
                }
            }
            
            addLog(`Downloaded ${generatedVisions.length} vision images`, 'success');
        }
        
        function clearAllVisions() {
            if (generatedVisions.length === 0) return;
            
            if (confirm(`Clear all ${generatedVisions.length} generated visions?`)) {
                generatedVisions = [];
                renderVisualsGallery();
                addLog('Cleared all generated visions', 'info');
            }
        }

        function updateClusterViz(result) {
            const stats = result.stats || {};
            
            document.getElementById('clusterNodes').textContent = stats.total_items || 0;
            document.getElementById('clusterCount').textContent = stats.clusters || Object.keys(result.archetypes || {}).length;
            document.getElementById('clusterEdges').textContent = stats.edges || '?';
            
            // Build legend
            const legend = document.getElementById('clusterLegend');
            const archetypes = Object.keys(result.archetypes || {});
            
            legend.innerHTML = archetypes.map((name, idx) => `
                <div class="legend-item">
                    <div class="legend-dot" style="background: ${CLUSTER_COLORS[idx % CLUSTER_COLORS.length]}"></div>
                    <span>${name.length > 20 ? name.slice(0, 20) + '...' : name}</span>
                </div>
            `).join('');
            
            drawClusterViz();
        }
        
        function drawClusterViz() {
            const canvas = document.getElementById('clusterCanvas');
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = container.clientWidth || 400;
            canvas.height = container.clientHeight || 300;
            
            const w = canvas.width;
            const h = canvas.height;
            
            // Clear
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, w, h);
            
            if (!currentResults || !currentResults.archetypes) {
                ctx.fillStyle = '#9ca3af';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Run mining to see cluster visualization', w/2, h/2);
                return;
            }
            
            const graph = currentResults.graph;
            const archetypes = Object.keys(currentResults.archetypes);
            
            // If we have graph data, use force-directed layout
            if (graph && graph.nodes && graph.nodes.length > 0) {
                drawForceGraph(ctx, w, h, graph, archetypes);
            } else {
                // Fallback to simple cluster view
                drawSimpleClusters(ctx, w, h, archetypes);
            }
        }
        
        function drawForceGraph(ctx, w, h, graph, archetypeNames) {
            const nodes = graph.nodes;
            const edges = graph.edges;
            
            // Create cluster color map
            const clusterColors = {};
            archetypeNames.forEach((name, idx) => {
                clusterColors[name] = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
            });
            
            // Initialize node positions with force-directed simulation
            const nodeMap = {};
            const margin = 40;
            
            // Group nodes by cluster for initial positioning
            const clusterGroups = {};
            nodes.forEach(node => {
                if (!clusterGroups[node.cluster]) clusterGroups[node.cluster] = [];
                clusterGroups[node.cluster].push(node);
            });
            
            // Position clusters in a circle, nodes within cluster with jitter
            const numClusters = Object.keys(clusterGroups).length;
            const clusterRadius = Math.min(w, h) * 0.32;
            const centerX = w / 2;
            const centerY = h / 2;
            
            Object.entries(clusterGroups).forEach(([cluster, clusterNodes], clusterIdx) => {
                const clusterAngle = (clusterIdx / numClusters) * Math.PI * 2 - Math.PI / 2;
                const clusterX = centerX + Math.cos(clusterAngle) * clusterRadius;
                const clusterY = centerY + Math.sin(clusterAngle) * clusterRadius;
                
                const nodeSpread = Math.min(50, 20 + clusterNodes.length * 2);
                
                clusterNodes.forEach((node, nodeIdx) => {
                    // Spiral layout within cluster
                    const spiralAngle = nodeIdx * 0.7;
                    const spiralRadius = 8 + nodeIdx * 3;
                    
                    nodeMap[node.id] = {
                        x: clusterX + Math.cos(spiralAngle) * Math.min(spiralRadius, nodeSpread),
                        y: clusterY + Math.sin(spiralAngle) * Math.min(spiralRadius, nodeSpread),
                        cluster: node.cluster,
                        color: clusterColors[node.cluster] || '#888888'
                    };
                });
            });
            
            // Simple force simulation (a few iterations)
            for (let iter = 0; iter < 50; iter++) {
                // Repulsion between all nodes
                Object.values(nodeMap).forEach(n1 => {
                    Object.values(nodeMap).forEach(n2 => {
                        if (n1 === n2) return;
                        const dx = n1.x - n2.x;
                        const dy = n1.y - n2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
                        if (dist < 30) {
                            const force = (30 - dist) * 0.05;
                            n1.x += (dx / dist) * force;
                            n1.y += (dy / dist) * force;
                        }
                    });
                });
                
                // Attraction along edges
                edges.forEach(edge => {
                    const s = nodeMap[edge.source];
                    const t = nodeMap[edge.target];
                    if (!s || !t) return;
                    
                    const dx = t.x - s.x;
                    const dy = t.y - s.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
                    
                    if (dist > 20) {
                        const force = (dist - 20) * 0.01;
                        s.x += (dx / dist) * force;
                        s.y += (dy / dist) * force;
                        t.x -= (dx / dist) * force;
                        t.y -= (dy / dist) * force;
                    }
                });
                
                // Keep nodes in bounds
                Object.values(nodeMap).forEach(n => {
                    n.x = Math.max(margin, Math.min(w - margin, n.x));
                    n.y = Math.max(margin, Math.min(h - margin, n.y));
                });
            }
            
            // Draw edges
            ctx.lineWidth = 0.5;
            edges.forEach(edge => {
                const s = nodeMap[edge.source];
                const t = nodeMap[edge.target];
                if (!s || !t) return;
                
                // Color by source cluster with low alpha
                ctx.strokeStyle = hexToRgba(s.color, 0.15);
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                ctx.lineTo(t.x, t.y);
                ctx.stroke();
            });
            
            // Draw nodes
            Object.values(nodeMap).forEach(node => {
                // Glow
                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 8);
                gradient.addColorStop(0, hexToRgba(node.color, 0.25));
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Node
                ctx.beginPath();
                ctx.arc(node.x, node.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = node.color;
                ctx.fill();
            });
            
            // Draw cluster labels
            Object.entries(clusterGroups).forEach(([cluster, clusterNodes], clusterIdx) => {
                // Find cluster centroid
                let cx = 0, cy = 0;
                clusterNodes.forEach(node => {
                    cx += nodeMap[node.id].x;
                    cy += nodeMap[node.id].y;
                });
                cx /= clusterNodes.length;
                cy /= clusterNodes.length;
                
                const color = clusterColors[cluster] || '#888888';
                
                // Label background
                const label = cluster.length > 15 ? cluster.slice(0, 15) + '...' : cluster;
                ctx.font = '10px Inter, sans-serif';
                const textWidth = ctx.measureText(label).width;
                
                ctx.fillStyle = 'rgba(10, 10, 15, 0.8)';
                ctx.fillRect(cx - textWidth/2 - 4, cy - 18, textWidth + 8, 14);
                
                // Label text
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, cx, cy - 11);
                
                // Node count
                ctx.fillStyle = '#666';
                ctx.font = '8px Inter, sans-serif';
                ctx.fillText(`${clusterNodes.length}`, cx, cy + 2);
            });
        }
        
        function drawSimpleClusters(ctx, w, h, archetypeNames) {
            // Fallback when no graph data available
            const numClusters = archetypeNames.length;
            const centerX = w / 2;
            const centerY = h / 2;
            const radius = Math.min(w, h) * 0.3;
            
            archetypeNames.forEach((name, idx) => {
                const angle = (idx / numClusters) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const color = CLUSTER_COLORS[idx % CLUSTER_COLORS.length];
                
                // Draw simple circle
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.fillStyle = hexToRgba(color, 0.25);
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Label
                ctx.fillStyle = color;
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';
                const label = name.length > 12 ? name.slice(0, 12) + '...' : name;
                ctx.fillText(label, x, y + 35);
            });
        }
        
        function exportJSON() {
            if (!currentResults) return;
            const blob = new Blob([JSON.stringify(currentResults, null, 2)], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `archetypes_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
        }
        
        function copyToClipboard() {
            if (!currentResults) return;
            navigator.clipboard.writeText(JSON.stringify(currentResults.archetypes, null, 2));
            addLog('Copied archetypes JSON to clipboard', 'success');
        }
        
        async function sendToExplorer() {
            if (!currentResults) return;
            
            // Store in localStorage for fallback
            localStorage.setItem('miner_archetypes', JSON.stringify(currentResults.archetypes));
            
            // Export to file via API (for Delyrism to read)
            try {
                const resp = await fetch('/api/export-to-delyrism', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Session-Id': sessionId },
                    body: JSON.stringify({ archetypes: currentResults.archetypes })
                });
                const result = await resp.json();
                if (result.success) {
                    addLog(`Exported ${result.count} archetypes to Delyrism`, 'success');
                    
                    // Visual feedback
                    const btn = document.querySelector('[onclick="sendToExplorer()"]');
                    if (btn) {
                        btn.textContent = ' Exported!';
                        btn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
                        setTimeout(() => {
                            btn.textContent = 'Open in Explorer';
                            btn.style.background = '';
                        }, 2000);
                    }
                } else {
                    addLog('Export failed: ' + result.error, 'error');
                }
            } catch (e) {
                addLog('Export API failed: ' + e.message, 'error');
            }
            
            // Send to parent Streamlit via postMessage (for iframe embed)
            try {
                window.parent.postMessage({
                    type: 'egregore_archetypes',
                    archetypes: currentResults.archetypes,
                    stats: currentResults.stats,
                    metrics: currentResults.metrics
                }, '*');
            } catch (e) {
                // Ignore if not in iframe
            }
        }
        
        // Handle window resize for cluster viz and 3D embeddings
        window.addEventListener('resize', () => {
            if (document.getElementById('results-clusters').classList.contains('active')) {
                drawClusterViz();
            }
            if (document.getElementById('results-metrics').classList.contains('active') && currentResults?.metrics) {
                const archetypeNames = Object.keys(currentResults.archetypes || {});
                draw3DEmbeddings(currentResults.metrics.embedding_coords || [], archetypeNames);
                if (currentResults.metrics.inter_similarity) {
                    drawSimilarityMatrix(currentResults.metrics.inter_similarity, archetypeNames);
                }
            }
            initSpectralCanvas();
        });
        
        // Spectral interference animation
        let spectralAnimationId = null;
        
        function initSpectralCanvas() {
            const canvas = document.getElementById('spectralCanvas');
            if (!canvas) return;
            
            const panel = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = panel.clientWidth * dpr;
            canvas.height = panel.clientHeight * dpr;
            canvas.style.width = panel.clientWidth + 'px';
            canvas.style.height = panel.clientHeight + 'px';
            
            if (!spectralAnimationId) {
                animateSpectral();
            }
        }
        
        function animateSpectral() {
            const canvas = document.getElementById('spectralCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const dpr = window.devicePixelRatio || 1;
            const time = performance.now() * 0.001;
            
            ctx.clearRect(0, 0, w, h);
            
            // Spectral line parameters
            const numWaves = 5;
            const colors = [
                'rgba(194, 166, 254, 0.3)',  // purple
                'rgba(161, 196, 253, 0.25)', // blue
                'rgba(139, 92, 246, 0.2)',   // violet
                'rgba(99, 102, 241, 0.15)',  // indigo
                'rgba(168, 85, 247, 0.2)'    // purple-pink
            ];
            
            for (let i = 0; i < numWaves; i++) {
                const freq1 = 0.003 + i * 0.001;
                const freq2 = 0.005 + i * 0.0008;
                const phase1 = time * (0.3 + i * 0.1);
                const phase2 = time * (0.2 + i * 0.15) + Math.PI * 0.5;
                const amplitude = 30 + i * 15;
                const yOffset = h * (0.2 + i * 0.15);
                
                ctx.beginPath();
                ctx.strokeStyle = colors[i % colors.length];
                ctx.lineWidth = (1.5 + Math.sin(time + i) * 0.5) * dpr;
                
                for (let x = 0; x < w; x += 2) {
                    // Interference pattern: sum of two sine waves
                    const wave1 = Math.sin(x * freq1 + phase1);
                    const wave2 = Math.sin(x * freq2 + phase2);
                    const interference = (wave1 + wave2) * 0.5;
                    
                    // Add subtle harmonic
                    const harmonic = Math.sin(x * freq1 * 3 + phase1 * 2) * 0.15;
                    
                    const y = yOffset + (interference + harmonic) * amplitude * dpr;
                    
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw interference nodes (bright spots where waves constructively interfere)
                for (let x = 0; x < w; x += 80) {
                    const wave1 = Math.sin(x * freq1 + phase1);
                    const wave2 = Math.sin(x * freq2 + phase2);
                    const interference = (wave1 + wave2) * 0.5;
                    
                    if (Math.abs(interference) > 0.8) {
                        const y = yOffset + interference * amplitude * dpr;
                        const nodeSize = (2 + Math.abs(interference) * 3) * dpr;
                        
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, nodeSize * 2);
                        gradient.addColorStop(0, colors[i % colors.length].replace('0.', '0.6'));
                        gradient.addColorStop(1, 'transparent');
                        
                        ctx.beginPath();
                        ctx.fillStyle = gradient;
                        ctx.arc(x, y, nodeSize * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Add subtle vertical scanning line
            const scanX = ((time * 30) % (w / dpr)) * dpr;
            const scanGradient = ctx.createLinearGradient(scanX - 20 * dpr, 0, scanX + 20 * dpr, 0);
            scanGradient.addColorStop(0, 'transparent');
            scanGradient.addColorStop(0.5, 'rgba(194, 166, 254, 0.08)');
            scanGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = scanGradient;
            ctx.fillRect(scanX - 20 * dpr, 0, 40 * dpr, h);
            
            spectralAnimationId = requestAnimationFrame(animateSpectral);
        }
        
        // Initialize spectral animation
        setTimeout(initSpectralCanvas, 100);
        
        // Info button tooltip handling - use a single tooltip appended to body
        function initTooltips() {
            // Create a single tooltip element appended to body to avoid stacking context issues
            const globalTooltip = document.createElement('div');
            globalTooltip.className = 'info-tooltip';
            globalTooltip.style.cssText = 'position: fixed; z-index: 999999; pointer-events: none;';
            document.body.appendChild(globalTooltip);
            
            const infoBtns = document.querySelectorAll('.info-btn');
            
            infoBtns.forEach(btn => {
                const tooltipContent = btn.querySelector('.info-tooltip');
                if (!tooltipContent) return;
                
                // Hide the original nested tooltip
                tooltipContent.style.display = 'none';
                
                btn.addEventListener('mouseenter', (e) => {
                    const rect = btn.getBoundingClientRect();
                    
                    // Copy content to global tooltip
                    globalTooltip.innerHTML = tooltipContent.innerHTML;
                    
                    // Make visible to measure
                    globalTooltip.style.visibility = 'visible';
                    globalTooltip.style.opacity = '1';
                    
                    // Force reflow to get accurate dimensions
                    const tooltipHeight = globalTooltip.offsetHeight;
                    const tooltipWidth = globalTooltip.offsetWidth || 220;
                    
                    // Calculate position - try above first
                    let left = rect.left + rect.width / 2 - tooltipWidth / 2;
                    let top = rect.top - tooltipHeight - 8;
                    
                    // Check if it goes off screen top, flip to below
                    if (top < 10) {
                        top = rect.bottom + 8;
                    }
                    
                    // Check if it goes off screen left/right
                    if (left < 10) left = 10;
                    if (left + tooltipWidth > window.innerWidth - 10) {
                        left = window.innerWidth - tooltipWidth - 10;
                    }
                    
                    // Apply final position
                    globalTooltip.style.left = left + 'px';
                    globalTooltip.style.top = top + 'px';
                });
                
                btn.addEventListener('mouseleave', () => {
                    globalTooltip.style.visibility = 'hidden';
                    globalTooltip.style.opacity = '0';
                });
            });
        }
        
        // Run tooltip init after a short delay to ensure DOM is ready
        setTimeout(initTooltips, 200);
        
        connect();
    </script>
</body>
</html>
